---
title: Renesas-RH850  CPU System - CPU -  Exceptions and Interrupts
date: 2025/1/4
categories: 
- Renesas
---

<center>

Renesas学习笔记
CPU System : CPU -  Exceptions and Interrupts

</center>

<!-- more -->

***
本章介绍此CPU上的异常和中断


异常是一种特定事件，会强制将操作从当前程序跳转到另一个程序。 
给定异常的跳转目标程序称为“异常处理程序”。

注意： 该 CPU 将中断作为异常的一种类型处理。

##### 1 异常概述
本节描述异常的工作原理。

###### 1.1 异常原因概述：
以下是 CPU 处理的异常原因概述。
- RESET：当输入重置信号时生成 RESET。详见第 3.2.8 节，重置。
- FENMI、FEINT 和 EIINT：这些是由中断控制器的中断信号生成的中断，以激活某个程序。
- SYSERR：这是一个系统错误异常。
在使用寄存器组功能自动保存上下文期间发生的错误会作为终止型 SYSERR 异常通知。在这种情况下，与确认中断的情况一样，异常发生时中断的指令的 PC 被加载到 FEPC 中，当时的 PSW 被加载到 FEPSW 中。使用 RESBANK 指令恢复上下文时发生的错误会作为可恢复型 SYSERR 异常通知。在这种情况下，RESBANK 指令的 PC 被加载到 FEPC 中，当时的 PSW 被加载到 FEPSW 中。
指令取回访问时发生的错误会作为可恢复型 SYSERR 异常通知。在这种情况下，待取回指令的 PC 被加载到 FEPC 中，当时的 PSW 被加载到 FEPSW 中。
与 SYSERR 异常相关的异常原因代码低 16 位：

    | 异常原因代码 | 原因                                             |
    | ------------ | ------------------------------------------------ |
    | 11H          | 指令取回时总线从设备发生响应错误*1                  |
    | 13H          | 指令取回时发生的安全功能范围内的错误（如 ECC 错误或奇偶校验错误） |
    | 1CH          | 自动将上下文保存到寄存器组时发生错误                  |
    | 1DH          | 从寄存器组恢复上下文时发生错误（执行 RESBANK 指令期间）|

    当从指令缓存中取回时发现 ECC 或奇偶校验错误时，它会被处理为缓存未命中，因此不会发生 SYSERR 异常。

- FPE：这是在执行浮点指令时发生的异常。详见第 3.2.6.1 节，浮点操作。
- FXE：这是在执行扩展浮点指令时发生的异常。详见第 3.2.6.2 节，扩展浮点操作。
- MIP 和 MDP：这是在 MPU 检测到违规时发生的异常。在计算指令将访问内存的地址时执行异常检测。详见第 3.2.5.1 节，内存保护单元 (MPU)。
在优先级确定结果中选择表引用方法中断 (EIINTn) 后，在执行表读取或自动保存上下文到寄存器组期间检测到 MDP 异常。在这种情况下，中断指令的执行并生成 MDP 异常（终止型），与普通中断相同。在这种情况下，中断指令的 PC 被保存到 FEPC 中，中断接受前建立的 PSW 被保存到 FEPSW 中。有关表引用方法的详细信息，请参见第 3.2.4.4 节，异常处理程序地址。

- RIE：这是一个保留指令异常。当尝试执行操作未定义的指令的操作码时，会发生此异常。操作与 RIE 指令相同。有关保留指令和 RIE 指令的详细信息，请参见 RH850G4MH 用户手册：软件。

- PIE：这是一个特权指令异常。当尝试执行没有所需特权的指令时，会发生此异常。

- UCPOP：这是在尝试执行不可用协处理器指令时发生的异常。

- MAE：这是在地址计算结果未对齐时发生的异常。

- TRAP、FETRAP 和 SYSCALL：这些是根据指令执行结果发生的异常。有关详细信息，请参见 RH850G4MH 用户手册：软件。


###### 1.2 异常类型
该 CPU 根据异常的执行方式将其分为以下三种类型：

- 终止型异常
- 可恢复型异常
- 挂起型异常

(a) 终止型异常：
对于此类型的异常，通过在当前指令的操作执行之前中断其来确认异常。这些异常包括中断等。

对于中断而言，它们的发生不依赖于当前指令的执行结果，即生成与该指令无关。当发生中断时，PSW.EP 位会被清除为 0，不同于其他异常。因此，当返回指令被执行时，异常处理程序例程的终止会报告给外部中断控制器。确保在 PSW.EP 位清除为 0 时从中断执行返回指令。

注意事项：

- 只有在确认中断（EIINTn、FEINT 或 FENMI）时，PSW.EP 位才会被清除为 0。当发生任何其他异常时，它被设置为 1。如果在 PSW.EP 位设置为 1 时执行从中断启动的异常处理程序例程的返回指令，外部中断控制器上的资源可能不会被释放，导致故障。

- 在执行执行多个内存访问的指令时，可能会接受终止型异常。在这种情况下，尽管指令的执行被终止，但已完成的内存访问结果不会被取消。例如，内存通过 PREPARE 指令更新，通用寄存器通过 DISPOSE 指令更新。但是，可以保证 PC 和 SP 保留重新执行指令所需的原始值。有关详细信息，请参见 RH850G4MH 用户手册：软件。相关指令如下：PREPARE、DISPOSE、PUSHSP、POPSP、RESBANK、STM.MP、LDM.MP。

- 对于执行加载访问和分支的指令，加载访问完成后可能会接受终止型异常。然而，保证完成指令后更新的 PC 和系统寄存器（如 CTPC）保留重新执行指令所需的原始值。有关详细信息，请参见 RH850G4MH 用户手册：软件。相关指令如下：CALLT、SYSCALL、SWITCH。

(b) 可恢复型异常
可恢复型异常是在指令操作期间发生的异常，并在未完成该指令的情况下被接受。它也称为精确异常，因为它在未完成正在执行的指令且未执行后续指令的情况下被精确地接受。此异常的发生抑制了通用寄存器和系统寄存器的更新。此外，**由于异常的返回 PC 指向导致异常的指令，因此可以在发生异常前的点恢复执行**。

可恢复型异常的返回 PC 是导致异常的指令的 PC（当前 PC）。

(c) 挂起型异常
这是在指令执行完成后确认的异常，作为执行指令操作的结果。挂起型异常包括软件异常。由于挂起型异常是正常指令执行的结果，因此当处理控制返回时，处理从导致挂起异常的指令的下一指令恢复。异常处理后，原始处理可以正常继续。

挂起型异常的返回 PC 是下一指令的 PC（下一 PC）。

###### 1.3 异常确认条件和优先级顺序
此 CPU 在特定时机基于异常确认条件和优先级顺序仅确认一个异常。待确认的异常基于异常确认条件和优先级顺序确定。

在表 3.102 中，确认条件列为“0”的异常，当对应位为“0”时可以被确认。当对应位为“1”时，这类异常不被接受。当它变为“0”并且满足确认条件时，异常确认变得可能。如果位上没有指定值，则不是确认条件。如果多个位被指定为条件，则必须同时满足所有条件。

某些异常具有专门的掩码功能，独特于其功能。基于单独定义的掩码功能对异常可接受性的决策在表 3.102 中列出的确认（接受）条件之前进行。有关详细信息，请参见各个异常原因的描述。

如果两个以上的异常同时满足确认条件，根据优先级顺序选择一个异常。优先级顺序在多个阶段确定；优先级级别，然后是优先级。数值越小，优先级越高。

当此 CPU 接受一个异常时，它会向请求模块返回接受响应。

如果终止型异常未被接受，CPU 不会将该异常请求挂起。为了保持异常请求挂起以供接受，发出终止型异常请求到 CPU 的模块（如中断控制器）会将异常请求挂起。

与重置同时发生的任何异常都不被接受。有关详细信息，请参见第 3.2.4.2 (1) 节，特殊操作。


###### 1.4 中断异常优先级和优先级屏蔽
通过设置寄存器，可以根据每个异常优先级或中断优先级屏蔽中断（EIINTn）。此功能允许在不需要维护的情况下，以更灵活的软件结构实现中断上限。图 3.17 显示了中断异常优先级和优先级屏蔽功能的概述。

(a) 中断优先级
此 CPU 支持以下中断（EIINTn）优先级级别：

- 当中断优先级级别扩展功能被禁用（INTCFG.EPL 被清除为 0）：最大 16 个优先级级别。

- 当中断优先级级别扩展功能被启用（INTCFG.EPL 被设置为 1）：最大 64 个优先级级别。 有关设置中断优先级的详细步骤，请参见第 6 节，中断。

(i) 当中断优先级级别扩展被禁用时（INTCFG.EPL 被清除为 0），发生优先级级别为 16 到 63 的中断：
- 此时中断（EIINTn）的确认功能有限。中断可以通过 ISPR 和 PLMR 屏蔽。如果 ISPR 的任意一个位被设置为 1，则所有优先级低于或等于 16 的中断（EIINTn）被屏蔽。PLMR 始终根据设置值和中断优先级级别判断确认，而不管中断优先级级别扩展功能的设置如何。另一方面，接受到的中断（EIINTn）的优先级信息不会保存在 ISPR 和 PSW.EIMASK 中。因此，尽管可能确认中断（EIINTn），但不推荐使用这种方式，因为 CPU 不处理优先级信息。


(ii) 优先级级别为 16 到 62 的中断的约束：无论中断优先级级别扩展功能是启用还是禁用，以下约束对优先级级别为 16 到 62 的中断（EIINTn）有效：

- 当接受到的中断（EIINTn）优先级在 16 到 62 之间，并且异常处理程序地址通过直接向量地址方法生成时，偏移地址为 1F0H，这与优先级为 15 的中断相同。因此，优先级低于或等于 15 的所有中断（EIINTn）使用相同的异常处理程序地址。有关详细信息，请参见第 3.2.4.4 节，异常处理程序地址。

- 当接受到的中断（EIINTn）优先级在 16 到 62 之间时，寄存器组的可用性由 RBCR0. BE[15] 指定，这与优先级为 15 的中断相同。优先级低于或等于 15 的所有中断（EIINTn），寄存器组的可用性不能按优先级级别指定。有关详细信息，请参见第 3.2.4.5 (2) 节，自动上下文保存。

- 当接受到的中断（EIINTn）优先级在 16 到 62 之间时，PSW. ID 位的值在保存到寄存器组后由 RBCR1. NC[15] 指定，这与优先级为 15 的情况相同。优先级低于或等于 15 的所有中断（EIINTn），在保存到寄存器组后，PSW. ID 位的值不能按优先级级别指定。有关详细信息，请参见第 3.2.4.5(2)(b) 节，抑制 PSW. ID 位的更新。

(iii) 优先级级别为 63 的中断的约束
如果中断优先级级别扩展功能被禁用，则优先级级别为 63（最低优先级级别）的中断（EIINTn）将始终被 PLMR 屏蔽。如果中断优先级级别扩展功能被启用，则优先级级别为 63（最低优先级级别）的中断（EIINTn）将始终被 PSW.EIMASK 屏蔽。因此，无论中断优先级级别扩展功能是否启用，优先级级别为 63 的中断（EIINTn）都不被接受。**但 HALT 指令引起的停止状态和 SNOOZE 指令引起的临时暂停状态可以通过发生优先级级别为 63 的中断释放。**

(b) 中断优先级屏蔽
如果中断优先级级别扩展功能被禁用（INTCFG.EPL 被清除为 0），中断（EIINTn）的确认通过 ISPR 和 PLMR 判断。如果中断优先级级别扩展功能被启用（INTCFG.EPL 被设置为 1），中断（EIINTn）的确认通过 PSW.EIMASK 和 PLMR 判断。

(i) ISPR
只有在中断优先级级别扩展功能被禁用时，中断确认由 ISPR 判断。 对于 ISPR 寄存器，当硬件确认中断时，对应优先级的位被设置为 1，并屏蔽相同或较低优先级的中断。当执行与中断对应的 EIRET 指令时，ISPR 寄存器的相应位被清除为 0，以清除屏蔽。 这种自动中断上限使得多个中断服务变得容易，无需使用软件控制。 INTCFG 寄存器的功能允许在确认和返回中断时禁用 ISPR 寄存器的自动更新。要在不使用 ISPR 寄存器功能的情况下通过软件执行中断上限控制，请将 INTCFG 寄存器中的 ISPC 位设置为 1，清除 ISPR 寄存器，然后使用 PLMR 寄存器通过软件控制上限值。

(ii) PSW.EIMASK
只有在中断优先级级别扩展功能被启用时，中断确认由 PSW.EIMASK 判断。 PSW.EIMASK 屏蔽优先级低于或等于设定值的中断（EIINTn）。当 CPU 确认中断（EIINTn）时，其中断优先级被存储。当执行 EIRET 或 FERET 指令时，存储 EIPSW.EIMASK 或 FEPSW.EIMASK 的值。PSW.EIMASK 的设置可以通过 LDSR 指令更改。

(iii) PLMR
PLMR 屏蔽优先级低于或等于设定值的中断（EIINTn）。 PLMR 寄存器允许通过软件屏蔽特定的中断优先级。用它来在程序中临时提高中断上限优先级。ISPR 寄存器或 PSW.EIMASK 指定的屏蔽设置与 PLMR 的屏蔽设置可能重叠，如果被其中任何一个屏蔽，中断就会被屏蔽。通常，使用 PLMR 寄存器提高 ISPR 寄存器或 PSW.EIMASK 的上限值。 此外，使用 PLMR 寄存器时，可以通过 ICSR 寄存器检查是否有任何中断被 PLMR 寄存器屏蔽。


###### 1.5 返回和恢复
当进行异常处理时，可能会影响被确认异常中断的原始程序。此影响从两个角度表示：“返回”和“恢复”。

- 返回：表示原始程序是否可以从中断处重新执行。
- 恢复：表示处理器状态（如通用寄存器和系统寄存器的状态）是否可以恢复到原始程序中断时的状态。

无法返回或恢复的异常（表 3.102 中标记为“否”）可能会导致返回 PC 丢失，使得无法通过返回指令从异常返回到原始处理。触发无法选择的异常是不可返回或不可恢复的异常。

对于不可恢复的异常，可以返回到原始程序流程。然而，由于在该点无法恢复发生异常前的状态，因此在继续后续程序操作时必须小心。

###### 1.6  上下文保存
为了在异常发生时保存当前程序序列，需根据功能定义适当地保存以下资源。某些资源由硬件自动保存，而某些资源需要由软件保存。

- 程序计数器（PC）
- 程序状态字（PSW）
- 异常原因代码（EIIC、FEIC）
- 工作系统寄存器（EIWR、FEWR）

使用哪种资源作为保存目标取决于异常类型。保存的资源确定如下所述。

对于使用寄存器组功能的异常，特定资源自动保存。有关详细信息，请参见第 3.2.4.5 节，寄存器组功能。

(a) 上下文保存
具有某些确认条件的异常在异常处理开始时可能不会被确认，这基于当另一个异常被确认时自动设置的挂起位（PSW. ID 和 NP 位）。

为了启用多重异常处理，使得同级别的异常再次可接受，必须保存返回寄存器和相应异常原因的某些信息，如保存到堆栈中。需要保存的这些信息称为“上下文”。

原则上，在保存上下文之前，必须确保不发生同级别的异常。

可以用于保存上下文工作并且其值保存以便根据需要处理多个异常的工作系统寄存器称为基本上下文寄存器。

这些基本上下文寄存器为每个异常级别提供。因此，当前异常的上下文在保存当前上下文之前发生不同级别的异常时不会被覆盖，因此可以精确地从当前异常返回。

| 异常级别 | 基本上下文寄存器              |
| -------- | ----------------------------- |
| EI 级别   | EIPC, EIPSW, EIIC, EIWR        |
| FE 级别   | FEPC, FEPSW, FEIC, FEWR        |



##### 2 确认异常时的操作
检查在指令执行期间报告的每个异常是否根据优先级被确认。特定异常确认操作的步骤如下所示。

1. 检查是否满足确认条件以及异常是否根据其优先级被确认。

2. 根据当前 PSW 值计算异常处理程序地址<sup>*1</sup>。

3. 对于 FE 级别异常，执行以下处理：
   - 将 PC 保存到 FEPC
   - 将 PSW 保存到 FEPSW
   - 将异常原因代码存储在 FEIC
   - 更新 PSW<sup>*2</sup>
   - 将步骤 (2) 中计算的异常处理程序地址存储在 PC 中，然后将控制传递给异常处理程序。

4. 对于 EI 级别异常，执行以下处理：
   - 将 PC 保存到 EIPC
   - 将 PSW 保存到 EIPSW
   - 将异常原因代码存储在 EIIC
   - 更新 PSW<sup>*2</sup>
   - 将步骤 (2) 中计算的异常处理程序地址存储在 PC 中，然后将控制传递给异常处理程序。
   - 当异常是使用寄存器组的中断时，自动保存上下文<sup>*3</sup>。

注意:
- *1：有关详细信息，请参见第 3.2.4.4 节，异常处理程序地址。 
- *2：有关要更新的值，请参见表 3.102。 
- *3：有关寄存器组的详细信息，请参见第 3.2.4.5 节，寄存器组功能。


###### 2.1 特殊操作
(a) PSW 寄存器的 EP 位
如果中断被确认，则 PSW.EP 位被清除为 0。如果确认的是中断以外的异常，则 PSW.EP 位被设置为 1。

CPU 在执行 EIRET 和 FERET 指令时的操作取决于 EP 位的状态。如果 EP 位被清除为 0，CPU 会通知外部中断控制器异常处理例程的终止。此功能对于在返回中断时正确控制中断控制器中的请求标志和其他资源是必要的。当 EP 位被清除为 0 并执行 EIRET 指令时，ISPR.ISP15 到 ISPR.ISP0 中设置为 1 的位中优先级最高的位（0 是最高）被清除为 0。

要从中断返回，请确保在 EP 位清除为 0 时执行返回指令。

(b) 协处理器不可用异常
对于协处理器不可用异常，导致异常的操作码取决于 PSW 寄存器的 CU 位的状态。

当产品中不包含协处理器或其不可用时，如果尝试执行对应协处理器的协处理器指令，则会立即发生协处理器不可用异常（UCPOP）。如果 LDSR 或 STSR 指令尝试访问协处理器的系统寄存器，也会立即发生协处理器不可用异常（UCPOP）。

有关详细信息，请参见第 3.2.2.4 (3) 节，协处理器不可用异常。

(c) 保留指令异常
如果执行了为未来功能扩展保留且未定义任何指令的操作码，则会发生保留指令异常（RIE）。

始终产生保留指令异常的操作码定义为 RIE 指令。

(d) Reset
Reset与异常处理方式相同，但不被视为 EI 级别异常或 FE 级别异常。Reset操作与无确认条件的异常相同，但每个寄存器的值更改为重置后的值。此外，从重置返回到原始程序是不可能的。

与 CPU 初始化同时发生的所有异常都会被取消，即使在 CPU 初始化后也不会被确认。

有关详细信息，请参见第 3.2.8 节，Reset。



##### 3 从异常处理中返回
要从异常处理中返回，请执行与相关异常级别对应的返回指令（EIRET 或 FERET）。

当上下文已保存（例如保存到堆栈）时，必须在执行返回指令之前恢复上下文。当从不可恢复的异常中返回执行时，无法恢复原始程序中发生异常前的状态。因此，执行结果可能与未发生异常时有所不同。

EIRET 指令用于从 EI 级别异常处理中返回，FERET 指令用于从 FE 级别异常处理中返回。

当执行 EIRET 或 FERET 指令时，CPU 执行以下处理，然后将控制传递到返回的 PC 地址。
1. 如果 PSW.EP 位被设置为 0，CPU 通知中断控制器异常处理例程的终止。

2. 当在 PSW.EP = 0 且 INTCFG.ISPC = 0 时执行 EIRET 指令，CPU 更新 ISPR 寄存器。执行 FERET 指令时，CPU 不更新 ISPR 寄存器。

3. 执行 EIRET 指令时，从 EIPC 和 EIPSW 寄存器加载返回的 PC 和 PSW。执行 FERET 指令时，从 FEPC 和 FEPSW 寄存器加载返回的 PC 和 PSW。

4. 将控制传递到加载的返回 PC 指示的地址。

图 3.19 显示了使用 EIRET 或 FERET 指令从异常处理中返回的流程。

希望这些翻译对你有帮助！如果你有任何其他问题或需要进一步的解释，请随时告诉我。




##### 4 异常处理程序地址
对于此 CPU，在复位输入、异常确认或中断确认期间用于执行的异常处理程序地址可以根据设置进行更改。

###### 4.1 复位、异常和中断
复位、异常和中断的异常处理程序地址通过直接向量方法确定，其中可以使用 PSW.EBV 位、RBASE 寄存器和 EBASE 寄存器更改异常处理程序地址的参考点。对于用户中断，还可以指定表引用方法。如果选择表引用方法，执行可以分支到内存中分配的异常处理程序表指示的地址。

(a) 直接向量方法
此 CPU 使用将表 3.105 中显示的偏移地址添加到 RBASE 或 EBASE 寄存器指示的基地址的结果作为异常处理程序地址。

**使用 RBASE 还是 EBASE 寄存器作为基地址是根据 PSW.EBV 位选择的**。如果 PSW.EBV 位设置为 1，则使用 EBASE 寄存器值作为基地址。如果该位被清除为 0，则使用 RBASE 寄存器值作为基地址。

然而，复位输入始终引用 RBASE 寄存器。

此外，用户中断（EIINTn）引用选定基寄存器的 RINT 位，并根据该位的值减少偏移地址。**如果 RBASE.RINT 位或 EBASE.RINT 位设置为 1，则所有用户中断使用 100H 的偏移地址进行处理**。如果该位被清除为 0，则偏移地址根据表 3.105 确定。


(b) 表引用方法
在直接向量方法中，每个中断优先级都有一个用户中断异常处理程序，并且具有相同优先级的用户中断分支到相同的中断处理程序，但某些用户可能希望为每个中断处理程序使用不同的代码区域。

为了适应这些需求，此 CPU 定义了一种表引用方法。


1: 在以下任一情况下，异常处理程序地址使用直接向量方法确定：
- 当中断通道设置不是表引用方法时。
- 当 PSW.EBV = 0 且 RBASE.DV = 1 时。
- 当 PSW.EBV = 1 且 EBASE.DV = 1 时。

2: 除上述情况外，计算表读取位置： 异常处理程序地址读取位置 = INTBP 寄存器 + 通道号 × 4 字节

3: 从步骤 (2) 中计算的异常处理程序地址读取位置开始读取字数据。

4: 使用步骤 (3) 中读取的字数据作为异常处理程序地址。

获取异常处理程序地址后，中断的接受得到确认。除了图 3.18 所示的异常接受处理外，CPU 返回接受响应给中断控制器并更新 ISPR。

**注意事项**:
- 有关中断通道设置的详细信息，请参见第 6 节，中断。
- 根据内存保护设置，在从异常处理程序地址读取位置读取字数据时，可能会发生内存保护异常 (MDP)。在这种情况下，中断的接受被暂时取消。由于没有返回接受响应给中断控制器，中断请求被挂起，并在从内存保护异常处理返回执行时重新变得可接受。

- 如果在从异常处理程序地址读取位置读取字数据时发生内存保护异常，被中断的指令的 PC 保存在 FEPC 中。由于中断的接受被取消，中断发生时建立的 PSW 值（应保存在 EIPSW 中）保存在 FEPSW 中。



###### 4.2 系统调用
对于系统调用异常，根据 SYSCALL 指令指定的向量值和 SCCFG.SIZE 位的值选择引用的表条目，并根据表条目的内容和 SCBP 寄存器值计算异常处理程序地址。

例如，如果 SCCFG.SIZE 指定的表大小为 n，则表条目按如下方式选择。注意，如果 SYSCALL 指令指定的向量（vector8）大于表大小 n，则向量 n+1 到 255 引用的表条目为表条目 0。


| 向量 | 异常原因代码               | 引用的表条目     |
| ---- | -------------------------- | ---------------- |
| 0    | 0000 8000H                 | 表条目 0         |
| 1    | 0000 8001H                 | 表条目 1         |
| 2    | 0000 8002H                 | 表条目 2         |
| ...  | ...                        | ...              |
| n-1  | 0000 8000H + (n-1)H        | 表条目 n-1       |
| n    | 0000 8000H + nH            | 表条目 n         |
| n+1  | 0000 8000H + (n+1)H        | 表条目 0         |
| ...  | ...                        | ...              |
| 254  | 0000 80FEH                 | 表条目 0         |
| 255  | 0000 80FFH                 | 表条目 0         |

**注意**：因为如果指定的向量超过 SCCFG.SIZE 指定的表大小时，表条目 0 被选择，因此请在表条目 0 处分配错误处理例程。




##### 5 寄存器组功能
此 CPU 提供寄存器组功能，当接受中断 (EIINTn) 时，自动保存上下文。由于上下文保存与中断接受处理并行进行，此功能使 CPU 能够实现高速中断响应。

###### 5.1 寄存器组功能概述
此 CPU 提供的寄存器组功能具有以下特点：
- 在满足某些条件时（见第 3.2.4.5 (2) 节，自动上下文保存），在接受中断 (EIINTn) 时自动保存上下文。
- 上下文保存的目标不是专用内存，而是安装在此 CPU 中的普通内存区域（由 RBIP 寄存器指定）。
- 要保存的上下文可以从两组中选择（由 RBCR0.MD 位指定）。
- 支持最多 64 级多重中断（RBNR.BN 位指示已接受中断的数量）。
- 
- 上下文通过执行 RESBANK 指令从寄存器组中恢复（没有自动恢复功能）。

###### 5.2 自动上下文保存
当通知的中断请求 (EIINTn) 满足以下条件时，进行自动上下文保存：

- 为中断请求指定了表引用方法<sup>*1</sup>。

- 寄存器组的使用由 RBCR0.BE[i] 位指定，该位与中断请求的优先级 (i) 相关联<sup>*2</sup>（启用自动上下文保存到寄存器组）。
- RBNR.BN 位的值不大于 INTCFG.ULNR 的值<sup>*3</sup>（检查正在使用的寄存器组数量）。

注意：
- *1：有关指定表引用方法的步骤，请参见第 6 节，中断。 
- *2：所有优先级小于等于 16 的中断 (EIINTn) 的上下文自动保存由 RBCR0.BE[15] 指定。 
- *3：如果 RBNR.BN 的值大于 INTCFG.ULNR 或 RBNR.BN 的值为 63，则不进行上下文自动保存。在这种情况下，异常因素代码（低 16 位）为 1CH 的 SYSERR 异常发生。

如果未为中断请求 (EIINTn) 指定表引用方法，或者未由与中断优先级 (i) 相关联的 RBCR0.BE[i] 位指定寄存器组的使用，则不进行自动上下文保存。

此外，如果 RBNR.BN 位的值大于 INTCFG.ULNR，或者 RBNR.BN 的值为 63，则不进行自动上下文保存。在这种情况下，假设正在执行意外的中断接受处理，并通知进行错误处理的终止型 SYSERR 异常。



(a) 自动上下文保存
以下是保存上下文到寄存器组的处理过程：

1. 根据寄存器组初始指针（RBIP）和接受中断时建立的寄存器组编号寄存器（RBNR）的 BN 位的值 (n) 计算上下文保存的寄存器组 n 的起始地址。寄存器组的大小 (BANK_SIZE) 取决于选择的保存模式。
   起始地址：RBIP – n × BANK_SIZE
   BANK_SIZE:
   - 保存模式 0：60H
   - 保存模式 1：90H

2. 根据 RBCR0.MD 位指定的保存模式<sup>*1</sup>，按照 RBNR.BN 位指定的寄存器组 n 保存目标寄存器。

3. 将 RBNR.BN 位的值加 1。这终止寄存器组保存处理<sup>*2</sup>，并开始执行中断处理程序<sup>*3</sup>。

注意事项
- *1：在寄存器组保存处理过程中进行的内存访问可能导致内存保护异常 (MDP)（终止型）。其他类型的中断和异常无法被接受。
- *2：不一定完成将寄存器保存到指定为寄存器组的内存区域。为了确保寄存器保存的完成，此 CPU 可以采用类似于普通存储指令的过程。有关详细信息，请参见第 3.2.7.2 节，保证存储指令的完成。
- *3：在保存到寄存器组后，可以接受较高优先级的异常。

以下是保存和恢复寄存器的地址、保存顺序和恢复顺序的列表：

表 3.108 要保存的寄存器、地址、保存顺序和恢复顺序
markdown
| 地址                     | 保存模式 0 (MD = 0) | 保存模式 1 (MD = 1) | 保存顺序      | 恢复顺序        |
| ------------------------ | ------------------ | ------------------ | ------------ | -------------- |
| RBIP - n × BANK_SIZE     |                      |                      |   *1，*2           | *1，*3               |
| -04H                     | PC                   | PC                   | 1            | 24 / 35        |
| -08H                     | PSW                  | PSW                  | 2            | 23 / 34        |
| -0CH                     | EIIC                 | EIIC                 | 3            | 22 / 33        |
| -10H                     | FPSR                 | FPSR                 | 4            | 21 / 32        |
| -14H                     | r1                   | r1                   | 5            | 20 / 31        |
| -18H                     | r2                   | r2                   | 6            | 19 / 30        |
| -1CH                     | r3                   | r3                   | 7            | 18 / 29        |
| -20H                     | r4                   | r4                   | 8            | 17 / 28        |
| -24H                     | r5                   | r5                   | 9            | 16 / 27        |
| -28H                     | r6                   | r6                   | 10           | 15 / 26        |
| -2CH                     | r7                   | r7                   | 11           | 14 / 25        |
| -30H                     | r8                   | r8                   | 12           | 13 / 24        |
| -34H                     | r9                   | r9                   | 13           | 12 / 23        |
| -38H                     | r10                  | r10                  | 14           | 11 / 22        |
| -3CH                     | r11                  | r11                  | 15           | 10 / 21        |
| -40H                     | r12                  | r12                  | 16           | 9 / 20         |
| -44H                     | r13                  | r13                  | 17           | 8 / 19         |
| -48H                     | r14                  | r14                  | 18           | 7 / 18         |
| -4CH                     | r15                  | r15                  | 19           | 6 / 17         |
| -50H                     | r16                  | r16                  | 20           | 5 / 16         |
| -54H                     | r17                  | r17                  | 21           | 4 / 15         |
| -58H                     | r18                  | r18                  | 22           | 3 / 14         |
| -5CH                     | r19                  | r19                  | 23           | 2 / 13         |
| -60H                     | r30                  | r20                  | 24           | 1 / 12         |
| -64H                     | *4                     | r21                  | 25           | 11             |
| -68H                     |                      | r22                  | 26           | 10             |
| -6CH                     |                      | r23                  | 27           | 9              |
| -70H                     |                      | r24                  | 28           | 8              |
| -74H                     |                      | r25                  | 29           | 7              |
| -78H                     |                      | r26                  | 30           | 6              |
| -7CH                     |                      | r27                  | 31           | 5              |
| -80H                     |                      | r28                  | 32           | 4              |
| -84H                     |                      | r29                  | 33           | 3              |
| -88H                     |                      | r30                  | 34           | 2              |
| -8CH                     |                      | r31                  | 35           | 1              |
| -90H                     |                    | *5                    |              |                |
| -94H                     |                    | *6                    |              |                |


注意：
- *1：寄存器保存和恢复按顺序编号 1 依次开始。
- *2：在保存模式 0 (RBCR0.MD = 0) 中，要保存的目标寄存器，是寄存器到r30，保存序列号为24。
- *3：左侧显示的恢复顺序编号适用于保存模式 0，右侧显示的适用于保存模式 1。
- *4：在保存模式 0 中，下一寄存器组 (n + 1) 从此地址开始。
- *5：在保存模式 1 中，此地址不保存任何寄存器。此地址不使用。
- *6：在保存模式 1 中，下一寄存器组 (n + 1) 从此地址开始。


(b) 抑制 PSW.ID 位的更新
在正常状态下接受中断 (EIINTn) 时，PSW.ID 位被设置为 1，并且除非通过 EI 指令显式启用中断接受，否则同一 EI 级别的中断无法被接受。

对于使用寄存器组的中断（满足自动上下文保存条件），通过将与中断优先级 (i) 相关联的 RBCR1.NC[i] 位清除为 0，接受中断时 PSW.ID 位保持为 0 而不会被设置为 1。这使得在自动上下文保存结束后，无需软件干预即可接受更高优先级的中断。由于必要的寄存器被自动保存，CPU 可以准确地返回到原始中断处理。

注意：接受中断后，所有优先级小于等于 16 的中断 (EIINTn) 的 PSW.ID 位由 RBCR1.NC[15] 定义。




###### 5.3 上下文恢复
自动保存到寄存器组的上下文需要在从中断处理返回到原始程序之前恢复。尽管上下文保存到寄存器组是自动完成的，**但其恢复需要通过软件显式执行 RESBANK 指令来完成**。

(a) 执行 RESBANK 指令的条件
必须执行 RESBANK 指令以从寄存器组恢复上下文。RESBANK 指令是监督特权指令。如果在用户模式下执行，则会发生 PIE 异常。

如果在 RBNR.BN 位的值为 0 时执行 RESBANK 指令，则会发生可恢复类型的 SYSERR 异常。RBNR.BN 位的值为 0 意味着没有上下文自动保存到寄存器组中。因此，如果在这种情况下执行 RESBANK 指令，将恢复无效值。


(b) 上下文恢复

RESBANK 指令从寄存器组恢复上下文的处理过程如下：

1. 根据寄存器组初始指针 (RBIP) 的值和接受中断时建立的寄存器组编号寄存器 (RBNR) 的 BN 位的值 (n) 计算上下文恢复的寄存器组 n-1 的起始地址。与保存上下文的情况不同，恢复上下文时引用的起始地址是寄存器组地址的下限。寄存器组的大小 (BANK_SIZE) 取决于选择的保存模式。

   起始地址：RBIP – n × BANK_SIZE
   BANK_SIZE:
   - 保存模式 0：60H
   - 保存模式 1：90H

2. 根据 RBCR0.MD 位指定的保存模式，从寄存器组 n-1 恢复目标寄存器中的上下文<sup>*1<sup>。

3. 将 RBNR.BN 位的值减 1<sup>*2</sup>。终止寄存器组恢复处理，并完成 RESBANK 指令的执行<sup>3</sup>。

注意事项：
- *1：CPU 在从寄存器组恢复上下文时可以接受终止型异常。内存访问可能导致内存保护异常 (MDP)（可恢复类型）。

- *2：当 CPU 在 RBNR.BN 的值更新之前接受异常时，即使尚未完成所有寄存器的恢复，也会停止执行 RESBANK 指令。在这种情况下，尽管有些寄存器的恢复已完成，但 CPU 无法知道哪些寄存器已恢复。由于异常的返回 PC 是 RESBANK 指令的 PC，如果在异常处理期间没有更改与 RESBANK 指令相关的资源，CPU 可以精确地重新执行 RESBANK 指令。

- *3：在执行 RESBANK 指令后，执行 EIRET 指令以从中断处理程序返回。



##### 6 内存访问异常列表
表 3.109 显示了进行内存访问的指令和异常列表以及可以检测到的异常。标有符号“✔”的异常可以在处理列出的指令和异常期间的内存访问中检测到。标有符号“×”的异常无法检测到。



| 指令/异常       | MAE | MDP | 指令/异常          | MAE | MDP |
| -------------- | --- | --- | ------------------ | --- | --- |
| SLD.B           | ×   | ✔   | PREPARE            | ×   | ✔   |
| SLD.BU          | ×   | ✔   | DISPOSE            | ×   | ✔   |
| SLD.H           | ✔   | ✔   | PUSHSP             | ×   | ✔   |
| SLD.HU          | ✔   | ✔   | POPSP              | ×   | ✔   |
| SLD.W           | ✔   | ✔   | STM.MP             | ×   | ✔   |
| SST.B           | ×   | ✔   | LDM.MP             | ×   | ✔   |
| SST.H           | ✔   | ✔   | SWITCH             | ×   | ✔   |
| SST.W           | ✔   | ✔   | CALLT              | ×   | ✔   |
| LD.B            | ×   | ✔   | SYSCALL            | ×   | ✔   |
| LD.BU           | ×   | ✔   | LDV.W              | ✔   | ✔   |
| LD.H            | ✔   | ✔   | LDV.DW             | ✔   | ✔   |
| LD.HU           | ✔   | ✔   | LDV.QW             | ✔   | ✔   |
| LD.W            | ✔   | ✔   | STV.W              | ✔   | ✔   |
| LD.DW           | ✔   | ✔   | STV.DW             | ✔   | ✔   |
| ST.B            | ×   | ✔   | STV.QW             | ✔   | ✔   |
| ST.H            | ✔   | ✔   | LDVZ.H4            | ✔   | ✔   |
| ST.W            | ✔   | ✔   | STVZ.H4            | ✔   | ✔   |
| ST.DW           | ✔   | ✔   | CACHE (CHBII)      | ×   | ✔   |
| LDL.BU          | ×   | ✔   | CACHE (CIBII)      | ×   | ×   |
| LDL.HU          | ✔   | ✔   | CACHE (CFALI)      | ×   | ✔   |
| LDL.W           | ✔   | ✔   | CACHE (CISTI)      | ×   | ×   |
| STC.B           | ×   | ✔   | CACHE (CILDI)      | ×   | ×   |
| STC.H           | ✔   | ✔   | CACHE (其他命令)   | ×   | ×   |
| STC.W           | ✔   | ✔   | PREF (PREFI)       | ×   | ×<sup>*1</sup>|
| CAXI            | ✔   | ✔   | PREF (其他命令)    | ×   | ×   |
| SET1            | ×   | ✔   | 表引用类型 EIINTn  | ×   | ✔ <sup>*2</sup>|
| CLR1            | ×   | ✔   | 寄存器组保存处理    | ×   | ✔ <sup>*2</sup>|
| NOT1            | ×   | ✔   | RESBANK            | ×   | ✔   |
| TST1            | ×   | ✔   |

注意:
- *1：在执行 PREF 指令期间检测到违规时，不会生成 MDP 异常，但会抑制内存访问。不执行读取访问。
- *2：由于表引用方法中断的表读取访问和自动将上下文保存到寄存器组的写入访问都独立于指令的执行发生。此 CPU 将这些访问引起的任何 MDP 异常视为终止型异常。此 MDP 异常的异常原因代码与可恢复型 MDP 异常的原因代码不同。有关详细信息，请参见表 3.102。

