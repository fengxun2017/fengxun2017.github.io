---
title: Renesas-RH850  CPU System - CPU - Processor Mode
date: 2024/12/4
categories: 
- Renesas
---

<center>

Renesas学习笔记
CPU System : CPU - Processor Mode

</center>

<!-- more -->

***

##### 1 CPU Operating Modes
该CPU有两种工作模式：管理模式(SV)和用户模式(UM)。系统是否处于管理模式或用户模式由PSW寄存器中的UM位指示。

监控模式 (PSW.UM = 0)：所有硬件功能都可以被管理或使用。

用户模式 (PSW.UM = 1)：可用的硬件功能受限。


###### 1.1 CPU工作模式定义
管理模式 (SV)：在这种模式下，所有硬件功能都可以被管理或使用。系统在复位后总是以监控模式启动。

用户模式 (UM)：在用户模式下，用户可以访问由管理模式允许访问的地址空间和系统寄存器。管理特权指令不能执行，使用会导致异常。


###### 1.2 CPU工作模式切换
CPU工作模式因三种事件而改变： 
- 由于确认异常引起的变化：当在用户模式下确认异常时，CPU工作模式切换为管理模式。 当在管理模式下确认异常时，CPU工作模式保持不变。

- 由于返回指令引起的变化：当执行返回指令时，PSW值根据备份到EIPSW和FEPSW的值恢复。

- 由于系统寄存器指令引起的变化 当使用 `LDSR` 指令直接覆盖PSW工作模式位时，CPU工作模式会发生变化。

**注意**：由于PSW寄存器的高位（第31到第5位）无法在用户模式下被覆盖，因此无法在用户模式下更改CPU操作模式，而在管理模式下则可以更改模式。该CPU保证，如果使用LDSR指令更新PSW寄存器，新设置将在后续指令执行时生效。然而，该CPU不保证新设置在 MPU 的内存保护中反映在后续指令的指令获取中。因此，建议使用返回指令来更改PSW寄存器的高位（第31到第5位）

###### 1.3 CPU操作模式（Operating Mode）和权限（Privileges）

在该CPU中，可用功能可以根据特定资源的使用权限设置和CPU操作模式进行限制。特定指令（包括更新特定系统寄存器的指令）只能在定义的操作模式下执行。执行这些特定指令所需的权限称为“特权”。在没有特权的操作模式下，这些指令不会执行，并且会发生异常。

该CPU定义了以下两种类型的权限（使用许可）：

- **管理（SV）特权**：操作重要系统资源、处理致命错误和管理用户模式程序执行所需的特权。这种特权在管理模式下可用。SV特权通常是执行用于操作重要系统资源的指令所需的，这些指令有时被称为SV特权指令。

- **协处理器使用权限**：使用协处理器所需的权限。无论CPU的操作模式如何，都可以指定是否可以使用协处理器。PSW寄存器中的CU2至CU0位由管理者用于指定每个程序是否可以使用协处理器。如果CU2至CU0位未设置为1，当执行相应的协处理器指令或访问系统寄存器时，会发生协处理器不可用异常。
如果没有安装协处理器，则无法将相应的CU位设置为1。如果管理者访问协处理器系统寄存器，就必须设置CU2至CU0位以启用协处理器使用。


**发生特权违规时的操作：** 当没有所需特权的人执行特权指令，或者当没有所需权限的人访问指定访问权限的系统寄存器时，会发生PIE异常或UCPOP异常。

###### 1.4 通过 HALT 指令进入 HALT 状态
执行 HALT 指令使 CPU 核心进入 HALT 状态。 当向 CPU 发出终止异常请求时，HALT 状态结束。在此时，如果满足终止异常的确认条件，控制权将转移到异常处理程序地址。即使不满足这些条件，当发出请求时，HALT 状态也会终止；因此，操作将从 HALT 指令后的指令恢复。


###### 1.5 通过 SNOOZE 指令进入临时暂停状态
SNOOZE 指令是一种在自旋锁期间减少总线带宽使用的指令。执行该指令后，CPU 核心进入临时暂停状态以限制后续指令的执行。程序员可以通过在自旋锁循环中插入此指令，避免因短期重复锁定过程而导致的不必要的总线带宽使用。

临时暂停状态在满足以下任一条件时结束：

在 SNZCFG 寄存器指定的时间过去后，恢复执行后续指令。

发生终止异常时，控制权转移到异常处理程序地址。如果不满足异常确认条件，则从 SNOOZE 指令后的指令继续执行。如果异常被确认，则中断 SNOOZE 指令后的指令，并且恢复的 PC 将指向 SNOOZE 指令后的指令。

###### 1.6 通过指令进行时间调整
如果需要调整程序执行的时间，可以使用特定指令 SYNCP。当连续执行 SYNCP 时，单条指令的周期数取决于 CPU 核心。对于 G4MH 核心，这个周期数是 3。为了调整时间，其他指令的周期数不被保证。


##### 2 Instruction Execution

如果可以确认终止异常，当在获取指令代码期间检测到异常或指令的执行特权不满足时，异常会在指令执行前发生。如果在CPU执行操作期间发生可恢复异常，它会中断操作的执行并确认异常。在这些情况下，指令操作的结果原则上不会反映在寄存器或内存中，CPU保留其在执行指令前的状态。

对于如软件异常之类的挂起异常，异常在指令执行结果已被反映（reflected）后被确认。

**注意：** 如果在执行以下指令期间确认异常，可能会将中间结果应用于内存或通用寄存器。然而，SP/EP不会更新。
- PREPARE, DISPOSE, PUSHSP, POPSP, STM.MP, LDM.MP

##### 3 Exceptions and Interrupts
异常和中断是导致正在执行的程序跳转到另一个程序的异常事件。异常和中断由各种来源触发，包括外设中断和程序异常。


###### 3.1 异常的类型
根据异常的目的，该CPU的异常分为以下三种类型：
- 终止异常（Terminating exception）
- 可恢复异常（Resumable exception）
- 挂起异常（Pending exception）

**终止异常**：终止异常是在指令操作执行之前，通过打断指令来确认的异常。终止异常包括中断等。此类异常，例如中断或硬件错误，会启动另一个与当前处理程序无关的程序。

**可恢复异常**：可恢复异常是在指令操作执行期间发生的异常，并且在指令未完成时被确认。这也称为精确异常，因为它是在相关指令未完成或后续指令未执行的情况下被精确地确认的。与终止异常不同，可恢复异常发生在指令执行期间，并取消指令的执行，因此允许在异常处理后再次执行指令。因此，通过在异常处理后适当地配置，重复执行相同的指令，可以在保持程序逻辑操作一致性的同时执行复杂的内存管理。

**挂起异常**：挂起异常是指在指令操作执行后发生的异常，并在指令完成后被确认。挂起异常包括软件异常等。挂起异常的发生被定义为指令的正常操作；因此，与可恢复异常不同，挂起异常通常完成导致它的指令，并且不会重新执行该指令。此异常主要用于调用门，例如，用于调用管理程序。

###### 3.2 异常级别
在该CPU中，如果在处理一个异常时发生了一个紧急程度较高的异常，则会优先处理紧急异常。为了在确认紧急异常后能够返回被中断的异常处理，即使上下文未保存到内存中，异常原因被分为以下两个层级进行管理：

- **EI** 级异常
- **FE** 级异常

**EI** 级异常用于处理常规用户处理、中断服务和操作系统处理等。
**FE** 级异常用于在处理 **EI** 级异常时，使系统中的高紧急程度中断或在操作系统处理期间可能发生的内存管理功能异常得到确认。

##### 4 Coprocessors
在该CPU中，集成了单精度和双精度浮点运算单元（FPU）和扩展浮点运算单元（FXU）。（根据产品的型号，这些协处理器可能不可用。）

###### 4.1 协处理器使用权限
要执行协处理器指令，需要有权限使用相应的协处理器指令。协处理器使用权限由`PSW.CU2`到`PSW.CU0`位指定，如果尝试执行相应协处理器使用权限被清除为0的指令，则会发生协处理器不可用异常（UCPOP）。

在以下情况下，PSW.CU2到CU0位的值固定为0并且不能更改：
- 协处理器功能未集成在产品中
- 根据产品功能，协处理器功能不可用

###### 4.2 协处理器使用权限与协处理器之间的对应关系
该CPU定义了协处理器使用权限，以在CPU操作期间控制每个程序的协处理器可用性。有三种协处理器使用权限（CU0到CU2），它们与协处理器的对应关系如下表所示。该CPU没有具有CU2协处理器使用权限的协处理器。CU2的协处理器使用权限是为将来与该CPU兼容的CPU保留的功能。

| 协处理器使用权限     | 协处理器     | 异常原因代码     |
|---------|---------|---------|
| CU0   | 单精度/双精度FPU   | 80<sub>H</sub>   |
| CU1   | FXU   | 81<sub>H</sub>   |
| CU2   | 预留    | 82<sub>H</sub>   |



###### 4.3 协处理器不可用异常
如果在没有相应协处理器使用权限（PSW.CUn = 0）的情况下尝试执行协处理器指令或访问协处理器的系统寄存器，则会发生协处理器不可用异常。如果使用寄存器组功能，在自动上下文保存和`RESBANK`指令执行时，会访问FPU的系统寄存器FPSR。在这种情况下，即使没有给予协处理器使用权限（PSW.CU0 = 0），也不会发生协处理器不可用异常。

###### 4.4 系统寄存器
某些协处理器功能具有特定的系统寄存器。访问协处理器功能的系统寄存器需要协处理器使用权限。对于某些系统寄存器，除了协处理器使用权限外，还需要监督特权（SV特权）。


##### 5 Registers
该CPU定义了程序寄存器（通用寄存器和程序计数器PC）和系统寄存器，用于控制状态和存储异常信息。

###### 5.1 程序寄存器
程序寄存器包括通用寄存器（r0到r31）和程序计数器（PC）。


| 类别 | 访问权限     | 名称    |
|---------|---------|---------|
| 程序计数器   | 用户模式 (UM)   | PC   |
| 通用寄存器   | 用户模式 (UM)   | r0-r31   |

备注：对具有用户模式（UM）访问权限的寄存器的访问始终被允许。

###### 5.2 系统寄存器
系统寄存器被放置在基于 Selection ID 和寄存器编号两种地址信息定义的专用地址空间中。最多可以定义32个 Selection ID，每个 Selection ID包括最多32个系统寄存器。因此，可以在系统寄存器的地址空间中定义最多1024个系统寄存器。基本上，该CPU分配 Selection ID如下：
- Selection ID 0到3：基本功能相关寄存器
- Selection ID 4和5：内存管理功能相关寄存器
- Selection ID 10和11：从传统架构扩展的功能相关寄存器
- Selection ID 12和13：该CPU特定硬件功能相关寄存器
- 其他ID：保留用于与该CPU兼容的未来CPU的扩展


###### 5.3 寄存器更新
有几种方法可以更新寄存器。通常，使用指令更新寄存器时没有特别的限制。然而，当使用以下指令更新寄存器时，根据操作模式可能会有一些限制：
- LDSR
- STSR

LDSR和STSR指令可以访问所有系统寄存器。但是，如果在没有适当权限的情况下访问系统寄存器，可能会发生PIE异常或UCPOP异常。


###### 5.4 访问未定义寄存器
如果访问没有分配任何寄存器的系统寄存器编号或访问不可访问的寄存器，会发生以下结果：
- 未定义寄存器被视为具有SV权限。当在用户模式（PSW.UM = 1）下通过LDSR或STSR指令访问它们时，会发生PIE异常。
- 对于读取操作，读取结果未定义。如果程序中使用了读取值，可能会发生意外行为。
- 对于写入操作，写入操作被忽略。

###### 5.5 监督锁定设置
如果设置了SVLOCK.SVL位，则即使在监督模式下也不能更新以下系统寄存器： SPID, MPM, MPLA, MPUA, MPAT, MPIDn, 和 MPBK。
然而，如果设置了SVLOCK.SVL位，尝试更新上述系统寄存器不会导致PIE异常。此外，即使设置了SVLOCK.SVL位，仍然可以读取上述系统寄存器。此功能旨在确保集成此CPU的系统的安全性。它防止在监督模式下运行的程序由于编程错误等原因突然更改内存保护设置，从而可能导致非法内存访问并损害安全性。


##### 6 Data Types

###### 6.1 数据格式
该CPU以小端格式处理数据。这意味着半字或字的第0字节，始终是最低有效（最右边的）字节。 支持的数据格式如下：
- 字节（8位数据）: 从任何字节边界开始的8个连续位的数据
- 半字（16位数据）: 半字是从任何字节边界开始的两个连续字节数据
- 字（32位数据）:字是从任何字节边界开始的四个连续字节数据
- 双字（64位数据）: 双字是从任何4字节边界开始的八个连续字节数据
- 四字（128位数据）: 四字是从任何8字节边界开始的十六个连续字节数据。
- 位（1位数据）

**在该CPU中，对双字数据的一次内存访问被划分为对字数据的两次非原子内存访问，对四字数据的一次内存访问被划分为对字数据的四次非原子内存访问**


###### 6.2 数据表示

**整数**:
整数以二进制值表示，使用二进制补码表示，并且以64位、32位、16位或8位的长度使用。由于这是二进制补码表示，最高有效位用作符号位。 各种数据长度的整数范围如下：

- 双字（64位）：−9223372036854775808 到 +9223372036854775807
- 字（32位）：−2147483648 到 +2147483647
- 半字（16位）：−32768 到 +32767
- 字节（8位）：−128 到 +127

虽然定义了四字（128位）数据格式，但该CPU不使用四字数据表示。这是因为四字数据由四个字数据或两个双字数据组成，但该CPU不直接处理四字数据。

**无符号整数**:
与可以取正负符号的“整数”不同，“无符号整数”永远不是负数。与整数一样，无符号整数以二进制值表示，并且以64位、32位、16位或8位的长度使用。无符号整数不使用符号位。 各种数据长度的无符号整数范围如下：

- 双字（64位）：0 到 18446744073709551615
- 字（32位）：0 到 4294967295
- 半字（16位）：0 到 65535
- 字节（8位）：0 到 255

**位**:
位数据作为单个位数据处理，值为清除（0）或设置（1）。有四种类型的位相关操作（如下所列），它们只针对内存空间中的单字节数据：
- 设置（Set）
- 清除（Clear）
- 反转（Invert）
- 测试（Test）

###### 6.3 数据对齐
在该CPU中，禁止未对齐的数据分配。当地址计算的结果是未对齐地址时，会发生未对齐异常（MAE）。 未对齐访问表示以下地址的数据大小的访问：

- 半字大小：访问不在半字边界（地址的最低有效位 = 0）上的地址
- 字大小：访问不在字边界（地址的最低两位 = 0）上的地址
- 双字大小：访问不在双字边界（地址的最低三位 = 0）上的地址
- 四字大小：访问不在四字边界（地址的最低四位 = 0）上的地址

**仅对于双字格式，当数据放置在字边界而不在双字边界时，不会发生未对齐访问异常，并且可以正常访问双字数据。**


##### 7  Address Space
该CPU支持高达4GB的线性地址空间。内存和I/O都可以映射到这个地址空间（使用内存映射I/O方法）。CPU为内存和I/O输出32位地址，其中最高地址编号为“2³² - 1”。 放置在各个地址的字节数据定义为位0为LSB（最低有效位），位7为MSB（最高有效位）。当数据由多个字节组成时，它定义为最低地址的字节数据是LSB，最高地址的字节数据是MSB（即小端格式）。 本手册规定，在表示由多个字节组成的数据时，右边代表低序地址，左边代表高序地址。

###### 7.1 内存映射
该CPU是32位架构，支持高达4GB的线性地址空间。整个4GB的地址空间可以通过指令寻址（指令获取访问）和数据寻址（数据访问）来寻址。

###### 7.2 指令寻址
指令地址基于程序计数器（PC）的内容确定，并根据执行指令的字节数自动递增。当执行分支指令时，使用下文所述的寻址方式将分支目标地址设置为PC。 如果地址计算结果通过加法超过正最大值FFFF FFFFH，则回绕到0000 0000H。如果地址计算结果通过减法低于正最小值0000 0000H，则回绕到FFFF FFFFH。

**相对寻址（PC相对）**：
指令代码中的有符号N位数据（位移：disp N）加到程序计数器（PC）。在这种情况下，位移作为二进制补码数据处理，MSB为符号位（S）。如果位移小于32位，高位扩展为符号扩展（N因指令不同而异）。 JARL, JR 和 Bcond 指令使用此类型的寻址。

**寄存器寻址（寄存器间接）**:
指令指定的通用寄存器（reg1）或系统寄存器（regID）的内容传送到程序计数器（PC）。 JMP, CTRET, EIRET, FERET 和 DISPOSE 指令使用此类型的寻址。

**基址寻址**:
指令指定的通用寄存器（reg1）和N位位移（dispN）的内容相加并传送到程序计数器（PC）。此时，位移作为二进制补码数据处理，MSB为符号位（S）。如果位移小于32位，高位扩展为符号扩展（N因指令不同而异）。 JMP 指令使用此类型的寻址。

**其他寻址**：
指令指定的值传送到程序计数器（PC）。值的指定方式在每条指令的[Operation]或[Description]部分解释。 CALLT, SYSCALL, TRAP, FETRAP 和 RIE 指令，以及异常情况下的分支使用此类型的寻址。

###### 7.3 数据寻址
执行指令时可以使用以下方法访问目标寄存器或内存。 如果地址计算结果通过加法超过正最大值FFFF FFFFH，则回绕到0000 0000H。如果地址计算结果通过减法低于正最小值0000 0000H，则回绕到FFFF FFFFH。

**寄存器寻址**：
此寻址方法访问在通用寄存器字段中指定为操作数的通用寄存器或系统寄存器。 任何包括操作数reg1、reg2、reg3或regID的指令都使用此类型的寻址。

**立即数寻址**：
此地址模式使用指令代码中的任意大小数据作为操作目标。 任何包括操作数imm5、imm16、vector或cccc的指令都使用此类型的寻址。

注：
- vector：这是指定异常向量（00H到1FH）的立即数数据，是TRAP、FETRAP和SYSCALL指令使用的操作数。数据宽度因指令而异。
- cccc：这是指定条件码的4位数据，是Bcond指令、CMOV指令、SASF指令和SETF指令使用的操作数。

**基址寻址**：
基地址寻址有两种类型，如下所述：

- 类型1 ：在指令代码中的寻址规范字段中指定的通用寄存器（reg1）的内容与N位位移（dispN）数据加上符号扩展到字长后得到操作数地址，并使用该操作数地址访问目标内存。在此过程中，位移作为二进制补码数据处理，最高有效位（MSB）作为符号位（S）。如果位移小于32位，则高位进行符号扩展（N因指令不同而不同）。 LD、ST、LDV和STV指令使用这种寻址类型。

- 类型2 ：元素指针（r30）的内容与N位位移数据（dispN）加零扩展到字长后得到操作数地址，并使用该操作数地址访问目标内存。如果位移小于32位，则高位进行零扩展（N因指令不同而不同）。 SLD和SST指令使用这种寻址类型。

**位寻址**：
在指令代码中指定的通用寄存器（reg1）的内容与N位位移（dispN）数据加上符号扩展到字长后得到操作数地址，并使用该操作数地址访问目标内存中的一个字节中的一个位（由3位数据“bit #3”指定）。在此过程中，位移作为二进制补码数据处理，最高有效位（MSB）作为符号位（S）。如果位移小于32位，则高位进行符号扩展（N因指令不同而不同）。 CLR1、SET1、NOT1和TST1指令使用这种寻址类型。

**后索引递增/递减寻址**：
通用寄存器（reg1）的内容用作操作数地址以访问目标内存，然后更新通用寄存器（reg1）。有两种更新通用寄存器的方法，分别是递增和递减。 如果递增通用寄存器（reg1）的值超过正最大值FFFF FFFFH，则结果回绕到0000 0000H；如果递减通用寄存器的值小于正最小值0000 0000H，则结果回绕到FFFF FFFFH。

- 类型1 ：通用寄存器（reg1）通过向其内容添加一个依赖于访问数据类型（访问数据的大小）的常量进行更新。如果访问数据的类型是字节，添加1；如果是半字，添加2；如果是字，添加4；如果是双字，添加8。
- 类型2 ：通用寄存器（reg1）通过从其内容中减去一个依赖于访问数据大小的常量进行更新。如果访问数据的大小是字节，减去1；如果是半字，减去2；如果是字，减去4；如果是双字，减去8。


**其他寻址**：
目标内存使用指令指定的值作为操作数地址进行访问。如何指定值在每个指令的[操作]或[描述]中说明。 SWITCH、CALLT、SYSCALL、PREPARE、DISPOSE、PUSHSP、POPSP、STM.MP和LDM.MP指令使用这种类型的寻址。


##### 8 Execution Timing of a Store Instruction
存储指令写入完成的时间可能因要访问的内存类型而异。有关详细信息，请参见第3.2.7.2节。

##### 9  Memory Ordering
该CPU保证按照编程顺序访问内存。然而，在包含多个总线主控设备（如DMA或多核的总线系统）的系统中，需要考虑对内存的访问顺序。对于这些情况，请参见第3.2.7.1节，同步处理。

##### 10 Acquiring the CPU Number
该CPU提供了一种在多处理器系统中识别CPU的方法。在多处理器配置中，可以通过参考PEID寄存器来识别哪个CPU核正在运行一个程序。根据产品的规格，PEID寄存器被分配了一个在多处理器系统中唯一的编号。

##### 11 System Protection Identifier (SPID)
在该CPU中，内存资源和外设设备由系统保护组管理。通过指定正在执行的程序所属的组，可以为该程序分配可访问的内存资源和外设设备。执行的程序属于由SPID指定的组，并且是否可访问内存资源和外设设备由SPID决定。值可以由监督者设置到SPID寄存器。


##### 12 Timestamp Counter
该CPU具有一个64位时间戳计数器。它可以测量很长的时间，因此可以用作时间识别的特定信息。由于时间戳计数器被分配到系统寄存器，因此可以通过使用LDSR/STSR指令快速访问。如果在计数操作期间发生溢出，则不会发生异常。

**时间戳计数器的操作方法**：
时间戳计数器的值在复位时初始化为0。因此，如果希望在复位期间保留计数器的值，则在复位之前将计数器的值保存到未被复位初始化的内存中，复位后将值恢复到计数器，并重新开始计数。计数器的宽度为64位，因此计数器由两个32位系统寄存器TSCOUNTL和TSCOUNTH组成。需要使用LDSR/STSR指令访问这两个寄存器。

当计数器未运行时（TSCTRL.CEN位的值为0），访问这两个寄存器不需要特别注意。然而，如果计数器正在运行（TSCTRL.CEN位的值为1），不建议使用LDSR指令更新计数器。在这种情况下，更新计数器的时序不受保证。建议在计数器未运行时更新计数器。

此外，当在计数器运行时使用STSR指令读取计数器的值时，建议遵循以下步骤：

```
TSCNTRD:
    STSR 1, r21, 11      ; 读取计数器的高位
    STSR 0, r20, 11      ; 读取计数器的低位
    STSR 1, r22, 11      ; 再次读取计数器的高位
    CMP   r21, r22       ; 比较两次读取的高位值
    BNE   TSCNTRD        ; 如果它们不相同，则发生进位。再次读取。
```
**即使在执行HALT或SNOOZE指令后CPU核心不在运行，时间戳计数器也会继续计数。**

##### 13 Performance Measurement Function
该CPU具有性能测量功能。性能测量功能可以通过计数由PMCTRLn.CND位指定的事件的发生次数来测量执行的程序的性能、操作期间生成的中断的影响等。

性能测量功能使用的系统寄存器在复位后只能在监督模式下访问。然而，通过更改PMUMCTRL寄存器的设置，也可以在用户模式下访问。无论PMUMCTRL寄存器的设置如何，性能测量功能本身在用户模式下工作。即使使用PMUMCTRL寄存器使所有性能测量通道在用户模式下不可访问，在监督模式下的配置也允许在用户模式下操作期间进行性能测量。

该CPU具有为性能测量功能设置的八个系统寄存器通道。