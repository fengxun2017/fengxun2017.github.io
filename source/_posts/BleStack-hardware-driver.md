---
title: 实现一个精简的BLE从机协议栈—1—依赖的相关硬件
date: 2023/3/25
categories: 
- BLE协议栈
---

<center>
实现一个精简的BLE从机协议栈——硬件基础
</center>

<!--more-->

***


- 本系列文章，基于`nordic nrf52840` MCU，来实现一个精简的 BLE 从机协议栈。
- 已经实现的协议栈地址：[https://github.com/fengxun2017/dh_ble/tree/dev](https://github.com/fengxun2017/dh_ble/tree/dev)，早期是基于`nrf51822`实现了`BLE 4.0`规范中从机协议栈中的必要部分，实现了可以和手机连接并传输数据。目前手上只有`nrf52840`了，当前基于`nrf52840`实现底层需要的驱动，并通过该系列文章，逐步修改一些上层不合理的地方。
- 该系列文章，涉及到的协议部分会基于`BLE 5.3`规范进行描述，但本协议并且仍旧只实现最简单、必要的部分（能连上手机，进行通信即可），基于 iphone进行测试。因此，android会由于发送一些我没实现的指令，出现兼容性问题。
- 本系列文章，只是用来作为学习 BLE 协议的参考，从硬件层驱动，链路层，到上层协议，都以最直接，简单的方式来实现。



本文描述与实现 `BLE` 相关的底层硬件相关基础。

`BLE`的普通广播（可连接、可扫描）形式如下图所示：
![](./BleStack-hardware-driver/ble-adv.png)

广播启动后，设备会周期性的进行广播。每次广播事件，设备会在37，38，39三个信道上，将广播数据广播一次（如上图左下所示），规范要求三个信道的广播数据发出间隔要小于10ms。

并且，每个信道发送完数据后，需要持续监听一个很短的时间（规范定义为F_IFS=150us），看是否有其它设备（扫描者，例如手机）发送了扫描请求（或连接请求）。 
如上图右下所示，设备在37信道广播后，没有监听到数据。之后开始在38信道上广播，广播完后监听到了扫描方发送的`扫描请求`，设备回复`扫描相应`。之后，设备继续在39信道上广播。

上图中 T_advEvent可以看做是广播间隔，它的实际值是：`T_advEvent = advInterval + advDelay`
`advDelay`是一个0-10ms的随机值。为什么要有这个随机值？ 因为范围内可能存在很多个设备都在广播，如果两个设备刚好同时启动，刚好广播周期又是一致，那么它们的物理信道就会一直冲突（同时使用同一个物理信道）。
通过引入的这个随机延迟`advDelay`，可以极大缓解物理信道冲突问题。


了解了广播的基本机制，再来看下`BLE`连接后的基本通讯模式：
![](./BleStack-hardware-driver/communication-mode.png)

连接建立后，`central`（发起连接的设备）和 `peripheral`（被连接设备）会周期性（以连接间隔为周期）的进行数据交互。（上图每次`central`和`peripheral`只交互了一次数据，实际是可以交互多包数据的）

从上图可以发现，`BLE` 的每次数据交互都是由`central`先发起的，从机再回复数据包。连接建立以后，`central`和`peripheral`会按照这个模式周期性的交互，即使我们没有数据需要发送，`central`和`peripheral`也会周期交互空包，这是为了维持连接，保持它们的同步关系。


无论是广播状态，还是连接状态。`BLE`的通讯模式都是“周期性”的。这也是`BLE`为什么低功耗的原因，对于 1 秒需要交互一次数据，每次只交互几十字节数据的设备来说。1秒钟的时间内，只有几百us的时间是处于工作作态的，其它时间设备都可以处于休眠状态，因此整体功耗可以做到非常低。

了解了`BLE`广播/连接状态下的基本情况，如何来实现它？
2.4G Radio是必备的，它是数据收发的载体。
其次，我们需要一个定时器，来实现周期广播，以及连接后的周期交互。

利用定时器，就可以做到不需要数据交互时（交互周期还没到），让设备休眠。当交互周期到达时（定时器超时），唤醒设备，进行数据收发。之后再次进入休眠状态，等待下一次定时器超时。如下图所示：
![](./BleStack-hardware-driver/anchor-point.png)

但现实中存在问题是，时钟都是有误差的。例如，假设`central`设备和`peripheral`设备上的时钟精度都是`100ppm`，即 1秒钟会存在 **±100us** 的误差。
因此，站在`peripheral`的角度，连接间隔 1秒 的情况下，我们不能不能刚好在 1秒 后才让设备唤醒让其监听（`central`）数据，而是需要考虑这个最大可能的误差，并根据这个最大可能误差提前唤醒设备。

这个最大可能的误差应该是 **central误差 + peipheral误差**（最大误差发送在两个设备的时间误差方向相反时），因此对于 1秒 连接间隔，`central`/`peripheral` 时钟误差都为`100ppm`的条件下，整体误差最大为`1000000us  *(100+100)/1000000 = ±200us`。
因此，实际实现时，需要在理论时间点上提前**200us**唤醒，如果没监听到数据，也需要持续监听到理论时间点之后**200us**的时间，如下图所示：



每次重新同步

rc震荡，无校准1s误差8ms， 有校准100us以内。
外部晶振产生HFCLK，驱动timer时钟源的源头就是来自HFCLK，2s 定时器的误差在10us内。