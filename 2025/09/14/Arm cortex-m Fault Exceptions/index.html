<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fengxun2017.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ARM Cortex-m Fault Exceptions 文档学习">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM Cortex-m Fault Exceptions 文档学习">
<meta property="og:url" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/index.html">
<meta property="og:site_name" content="fx">
<meta property="og:description" content="ARM Cortex-m Fault Exceptions 文档学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/exception-table.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/CFSR.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/MMFSR.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/BFSR.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/UFSR.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/ABFSR.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/handler_output.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Fault_Reports_dialog.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Faults_Reports_dialog.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Exception_stack_frame.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/display_call_stack.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Registers_Window.png">
<meta property="og:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Execution_context_stored_on_the_stack.png">
<meta property="article:published_time" content="2025-09-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-14T13:17:53.233Z">
<meta property="article:author" content="feng xun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/exception-table.png">


<link rel="canonical" href="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/","path":"2025/09/14/Arm cortex-m Fault Exceptions/","title":"ARM Cortex-m Fault Exceptions 文档学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ARM Cortex-m Fault Exceptions 文档学习 | fx</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <a target="_blank" rel="noopener" href="https://github.com/fengxun2017" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">fx</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">FreeRTOS交流QQ群-663806972 BLE学习交流群-498676838</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%85%E9%9A%9C%E5%BC%82%E5%B8%B8-Fault-exception-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">1 故障异常(Fault exception)处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%85%E9%9A%9C%E5%BC%82%E5%B8%B8-Fault-exception-%E7%9A%84%E7%BC%96%E5%8F%B7%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.</span> <span class="nav-text">2 故障异常(Fault exception)的编号与优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%98%E5%85%88%E7%BA%A7%E6%8F%90%E5%8D%87%EF%BC%88Priority-Escalation%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">3 优先级提升（Priority Escalation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-BusFault%EF%BC%88%E6%80%BB%E7%BA%BF%E6%95%85%E9%9A%9C%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">4 同步与异步 BusFault（总线故障）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%85%E9%9A%9C%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">5 故障异常的控制寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%95%85%E9%9A%9C%E5%BC%82%E5%B8%B8%E7%9A%84%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">6 故障异常的状态寄存器与地址寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-HardFault-%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88HFSR%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 HardFault 状态寄存器（HFSR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%8F%AF%E9%85%8D%E7%BD%AE%E6%95%85%E9%9A%9C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-CFSR-Configurable-Fault-Status-Register"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 可配置故障状态寄存器 (CFSR - Configurable Fault Status Register)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-MMFSR-MemManage-Status-Register"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 内存管理状态寄存器 (MMFSR - MemManage Status Register)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-2-%E6%80%BB%E7%BA%BF%E6%95%85%E9%9A%9C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-BFSR-BusFault-Status-Register"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 总线故障状态寄存器 (BFSR - BusFault Status Register)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-3-%E7%94%A8%E6%B3%95%E6%95%85%E9%9A%9C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-UFSR-UsageFault-Status-Register"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 用法故障状态寄存器 (UFSR - UsageFault Status Register)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%95%85%E9%9A%9C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-MMFAR-MemManage-Fault-Address-Register"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 内存管理故障地址寄存器 (MMFAR - MemManage Fault Address Register)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4%E6%80%BB%E7%BA%BF%E6%95%85%E9%9A%9C%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-BFAR-BusFault-Address-Register"><span class="nav-number">6.4.</span> <span class="nav-text">6.4总线故障地址寄存器 (BFAR - BusFault Address Register)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-%E8%BE%85%E5%8A%A9%E6%80%BB%E7%BA%BF%E6%95%85%E9%9A%9C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-ABFSR-Auxiliary-Bus-Fault-Status-Register-%E4%BB%85-Cortex-M7"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 辅助总线故障状态寄存器 (ABFSR - Auxiliary Bus Fault Status Register) (仅 Cortex-M7)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">7 实现故障处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-HardFault-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 HardFault 处理程序示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-ARM-Cortex-M7-%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 ARM Cortex-M7 故障处理注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BD%BF%E7%94%A8-%C2%B5Vision%C2%AE-%E8%B0%83%E8%AF%95%E6%95%85%E9%9A%9C"><span class="nav-number">8.</span> <span class="nav-text">8 使用 µVision® 调试故障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E4%BB%8E%E2%80%9C%E5%A4%96%E8%AE%BE%E2%80%9D%E8%8F%9C%E5%8D%95%E8%AE%BF%E9%97%AE%E6%95%85%E9%9A%9C%E6%8A%A5%E5%91%8A%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 从“外设”菜单访问故障报告对话框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-%E7%A1%AE%E5%AE%9A%E5%BC%82%E5%B8%B8%E5%8F%91%E7%94%9F%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 确定异常发生的位置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">参考连接：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">feng xun</p>
  <div class="site-description" itemprop="description">FreeRTOS交流QQ群-663806972 BLE学习交流群-498676838</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="feng xun">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fx">
      <meta itemprop="description" content="FreeRTOS交流QQ群-663806972 BLE学习交流群-498676838">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ARM Cortex-m Fault Exceptions 文档学习 | fx">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ARM Cortex-m Fault Exceptions 文档学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-14 00:00:00" itemprop="dateCreated datePublished" datetime="2025-09-14T00:00:00+08:00">2025-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ARM-CORTEX-M/" itemprop="url" rel="index"><span itemprop="name">ARM-CORTEX-M</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>
ARM Cortex-m Fault Exceptions 文档学习
</center>

<span id="more"></span>

<hr>
<p>为了尽早发现问题，所有 Cortex-M 处理器都内建了故障异常机制。当检测到故障时，相应的故障异常会被触发，并执行对应的异常处理程序。本文档介绍了故障异常的使用方法，列出了系统控制块（System Control Block，SCB）中用于控制故障异常或提供故障原因信息的外设寄存器。文中还通过软件示例展示了故障异常在程序调试过程中或在应用软件中进行错误恢复时的使用方式。</p>
<h3 id="1-故障异常-Fault-exception-处理程序"><a href="#1-故障异常-Fault-exception-处理程序" class="headerlink" title="1 故障异常(Fault exception)处理程序"></a>1 故障异常(Fault exception)处理程序</h3><p>故障异常用于捕获非法的内存访问和非法的程序行为。以下几种情况可由故障异常处理程序检测：</p>
<ul>
<li><p>HardFault（硬故障）：这是默认的异常类型，通常在异常处理过程中发生错误，或当某个异常无法由其他异常机制处理时触发。</p>
</li>
<li><p>MemManage（内存管理故障）：用于检测对由内存管理单元（MPU）定义的区域的非法访问。例如，在仅具有读&#x2F;写权限的内存区域执行代码。</p>
</li>
<li><p>BusFault（总线故障）：用于检测指令获取、数据读写、中断向量获取以及中断时寄存器堆栈操作（保存&#x2F;恢复）中的内存访问错误。</p>
</li>
<li><p>UsageFault（使用故障）：用于检测未定义指令的执行、非对齐的多数据加载&#x2F;存储访问。当启用后，还可检测除以零和其他非对齐的内存访问。</p>
</li>
</ul>
<h3 id="2-故障异常-Fault-exception-的编号与优先级"><a href="#2-故障异常-Fault-exception-的编号与优先级" class="headerlink" title="2 故障异常(Fault exception)的编号与优先级"></a>2 故障异常(Fault exception)的编号与优先级</h3><p>每个异常都具有一个对应的异常编号和优先级编号。为了简化软件层的处理，CMSIS（Cortex Microcontroller Software Interface Standard）仅使用 IRQ 编号，因此对于非中断类的异常使用负值表示。<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/exception-table.png"></p>
<p>HardFault 异常始终处于启用状态，并具有固定优先级（高于其他中断和异常，但低于不可屏蔽中断 NMI）。因此，在某个故障异常被禁用，或在执行某个故障异常处理程序期间发生新的故障时，HardFault 异常将被触发执行。</p>
<p>其他故障异常（如 MemManage、BusFault 和 UsageFault）具有可编程的优先级。在系统复位后，这些异常默认处于禁用状态，可以通过系统或应用软件中的系统控制块（System Control Block，SCB）寄存器进行启用。</p>
<h3 id="3-优先级提升（Priority-Escalation）"><a href="#3-优先级提升（Priority-Escalation）" class="headerlink" title="3 优先级提升（Priority Escalation）"></a>3 优先级提升（Priority Escalation）</h3><p>通常，异常的优先级与异常屏蔽寄存器的值共同决定处理器是否进入故障处理程序，以及一个故障处理程序是否可以抢占另一个故障处理程序。</p>
<p>在某些情况下，具有可配置优先级的故障会被当作 HardFault（硬故障）处理。这种情况称为优先级提升，即故障被“提升”为 HardFault。以下情况会触发优先级提升（“优先级提升”，是新发生的故障被“强制”转为 HardFault 来处理。）：</p>
<ul>
<li>故障处理程序在处理某类故障时再次引发相同类型的故障。由于处理程序无法抢占自身（其优先级与当前处理级别相同），因此会被提升为 HardFault。</li>
<li>故障处理程序引发了一个优先级相同或更低的故障。由于新故障的处理程序无法抢占当前正在执行的处理程序，因此会被提升为 HardFault。</li>
<li>异常处理程序引发了一个优先级相同或更低的故障。同样由于抢占失败，故障会被提升为 HardFault。</li>
<li>发生故障时，其对应的处理程序未启用。此时系统无法进入该处理程序，只能转而执行 HardFault。</li>
</ul>
<p>如果在进入 BusFault 处理程序时，堆栈压入操作（stack push）过程中发生 BusFault，该故障不会被提升为 HardFault。这意味着即使堆栈损坏导致故障，处理器仍会执行 BusFault 处理程序，尽管堆栈内容可能已损坏。</p>
<p>注意事项：</p>
<ul>
<li>只有 复位（Reset） 和 不可屏蔽中断（NMI） 可以抢占固定优先级的 HardFault。</li>
<li>HardFault 可以抢占除 Reset、NMI 和另一个 HardFault 之外的任何异常。</li>
</ul>
<h3 id="4-同步与异步-BusFault（总线故障）"><a href="#4-同步与异步-BusFault（总线故障）" class="headerlink" title="4 同步与异步 BusFault（总线故障）"></a>4 同步与异步 BusFault（总线故障）</h3><p>BusFault 可细分为两类：同步总线故障与异步总线故障。故障处理程序可通过 BFSR（BusFault Status Register，总线故障状态寄存器） 来判断故障类型：<br>PRECISERR 表示同步（精确）故障；<br>IMPRECISERR 表示异步（不精确）故障。</p>
<p>同步总线故障（Synchronous BusFault &#x2F; Precise BusFault）</p>
<ul>
<li>指在总线传输完成后立即发生的异常。</li>
<li>这种故障是可定位的，因为它与当前指令直接相关。</li>
<li>如果在 NMI 或 HardFault 处理程序内部发生同步 BusFault，可能会导致系统锁死（lockup）。</li>
<li>缓存维护操作（如清除或失效）也可能触发同步 BusFault。</li>
<li>调试访问（如调试器的加载或存储操作）也可能触发 BusFault，这类访问是同步的，仅对调试接口可见。</li>
</ul>
<p>异步总线故障（Asynchronous BusFault &#x2F; Imprecise BusFault）</p>
<ul>
<li>通常由于处理器设计中的写缓冲机制引起。</li>
<li>处理器流水线会继续执行后续指令，而在稍后才观察到总线错误响应。</li>
<li>如果此时有更高优先级的中断到达，异步 BusFault 会被挂起（pended），先执行该中断处理程序，之后再处理 BusFault。</li>
<li>如果 BusFault 处理程序未启用，则会挂起一个 HardFault 异常来代替处理。</li>
<li>异步 BusFault 引发的 HardFault 不会导致系统锁死。</li>
<li><strong>异步故障通常是不可恢复的，因为无法确定是哪条指令导致了错误</strong>。</li>
</ul>
<h3 id="5-故障异常的控制寄存器"><a href="#5-故障异常的控制寄存器" class="headerlink" title="5 故障异常的控制寄存器"></a>5 故障异常的控制寄存器</h3><p>系统控制块（System Control Block，SCB）提供了系统实现信息和系统控制功能，包括系统异常的配置、控制与状态报告。其中有几个关键寄存器用于控制故障异常：</p>
<p>CCR（Configuration and Control Register，配置与控制寄存器） 控制 UsageFault 异常的行为，特别是是否启用对“除以零”和“非对齐内存访问”的检测。</p>
<ul>
<li><p>DIV_0_TRP：当处理器执行 SDIV 或 UDIV 指令且除数为 0 时，是否触发 UsageFault 异常：、</p>
<ul>
<li>0：不触发异常，除以零的结果返回为 0；</li>
<li>1：触发异常，进入 UsageFault 处理程序。</li>
</ul>
</li>
<li><p>UNALIGN_TRP：当进行非对齐地址的内存访问时，是否触发 UsageFault 异常：</p>
<ul>
<li>0：不触发异常，允许非对齐的半字和字访问；</li>
<li>1：触发异常，非对齐访问将引发 UsageFault。</li>
<li>注意：即使 UNALIGN_TRP 设置为 0，使用 LDM、STM、LDRD 和 STRD 指令进行非对齐访问仍会触发 UsageFault。</li>
</ul>
</li>
</ul>
<p>SHP（System Handler Priority Registers，系统管理程序优先级寄存器） 用于设置系统异常（如 MemManage、BusFault、UsageFault、SVCall 等）的优先级。 每个异常都有对应的优先级字段，优先级值越小，优先级越高。以下索引对应故障异常的优先级设置：</p>
<ul>
<li>SHP[0]：内存管理故障（Memory Management Fault）的优先级；</li>
<li>SHP[1]：总线故障（BusFault）的优先级；</li>
<li>SHP[2]：使用故障（UsageFault）的优先级。</li>
</ul>
<p>使用 CMSIS 提供的函数设置优先级示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NVIC_SetPriority(MemoryManagement_IRQn, <span class="number">0x0F</span>); <span class="comment">// 设置 MemManage 优先级为最低</span></span><br><span class="line">NVIC_SetPriority(BusFault_IRQn, <span class="number">0x08</span>);         <span class="comment">// 设置 BusFault 优先级为中等</span></span><br><span class="line">NVIC_SetPriority(UsageFault_IRQn, <span class="number">0x01</span>);       <span class="comment">// 设置 UsageFault 优先级为较高</span></span><br><span class="line"></span><br><span class="line">UsageFault_prio = NVIC_GetPriority(UsageFault_IRQn); <span class="comment">// 读取 UsageFault 当前优先级</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SHCSR（System Handler Control and State Register，系统管理程序控制与状态寄存器） 用于启用系统异常处理器，并报告某些异常的挂起状态。 包括 MEMFAULTENA、BUSFAULTENA、USGFAULTENA 等位，用于启用对应的异常处理器。 还包含 SVCALLPENDED、BUSFAULTPENDED 等位，用于指示异常是否处于挂起状态。</p>
<p>启用所有故障异常的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCB-&gt;SHCSR |= SCB_SHCSR_USGFAULTENA_Msk </span><br><span class="line">           | SCB_SHCSR_BUSFAULTENA_Msk</span><br><span class="line">           | SCB_SHCSR_MEMFAULTENA_Msk; <span class="comment">// 启用 UsageFault、BusFault 和 MemManage 异常</span></span><br></pre></td></tr></table></figure>

<h3 id="6-故障异常的状态寄存器与地址寄存器"><a href="#6-故障异常的状态寄存器与地址寄存器" class="headerlink" title="6 故障异常的状态寄存器与地址寄存器"></a>6 故障异常的状态寄存器与地址寄存器</h3><p>下表列出了各类故障异常对应的状态寄存器和地址寄存器，并标明了每个寄存器在内存中的地址：</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>状态寄存器</th>
<th>地址寄存器</th>
<th>寄存器地址</th>
<th>描述说明</th>
</tr>
</thead>
<tbody><tr>
<td>HardFault</td>
<td>HFSR</td>
<td>—</td>
<td><code>0xE000ED2C</code></td>
<td>硬故障状态寄存器（HardFault Status Register）</td>
</tr>
<tr>
<td>MemManage</td>
<td>MMFSR</td>
<td>MMFAR</td>
<td><code>0xE000ED28</code>（状态）<br><code>0xE000ED34</code>（地址）</td>
<td>内存管理故障状态寄存器与地址寄存器</td>
</tr>
<tr>
<td>BusFault</td>
<td>BFSR</td>
<td>BFAR</td>
<td><code>0xE000ED29</code>（状态）<br><code>0xE000ED38</code>（地址）</td>
<td>总线故障状态寄存器与地址寄存器</td>
</tr>
<tr>
<td>UsageFault</td>
<td>UFSR</td>
<td>—</td>
<td><code>0xE000ED2A</code></td>
<td>使用故障状态寄存器</td>
</tr>
<tr>
<td></td>
<td>AFSR</td>
<td>—</td>
<td><code>0xE000ED3C</code></td>
<td>辅助故障状态寄存器，内容由实现定义</td>
</tr>
<tr>
<td></td>
<td>ABFSR</td>
<td>—</td>
<td><code>0xE000ED3C</code></td>
<td>辅助总线故障状态寄存器，仅适用于 Cortex-M7</td>
</tr>
</tbody></table>
<h4 id="6-1-HardFault-状态寄存器（HFSR）"><a href="#6-1-HardFault-状态寄存器（HFSR）" class="headerlink" title="6.1 HardFault 状态寄存器（HFSR）"></a>6.1 HardFault 状态寄存器（HFSR）</h4><p>HardFault 状态寄存器用于指示处理器指令的错误使用情况，包含以下状态位：</p>
<ul>
<li>VECTTBL：表示在异常处理过程中读取向量表时发生了总线故障（BusFault）：<ul>
<li>0：读取向量表时未发生总线故障；</li>
<li>1：读取向量表时发生了总线故障。</li>
<li>当该位被置位时，异常返回时堆栈中的 PC 值指向的是被异常抢占的指令位置(这个被压入堆栈的PC值一般不指向导致总线错误的那条指令（比如一条错误的内存访问指令）。相反，它指向的是被异常抢占的那个任务的指令流中的某条指令)。此类错误始终被视为 HardFault。</li>
</ul>
</li>
<li>FORCED：表示强制性 HardFault，由无法处理的可配置优先级故障升级而来（可能由于优先级问题或异常处理器未启用）：<ul>
<li>0：未发生强制性 HardFault；</li>
<li>1：发生了强制性 HardFault。</li>
<li>当该位被置位时，HardFault 处理程序应读取其他故障状态寄存器，以确定故障的具体原因。</li>
</ul>
</li>
<li>DEBUGEVT：保留用于调试用途。在向该寄存器写入时，必须将此位写为 0，否则行为不可预测。</li>
</ul>
<h4 id="6-2-可配置故障状态寄存器-CFSR-Configurable-Fault-Status-Register"><a href="#6-2-可配置故障状态寄存器-CFSR-Configurable-Fault-Status-Register" class="headerlink" title="6.2 可配置故障状态寄存器 (CFSR - Configurable Fault Status Register)"></a>6.2 可配置故障状态寄存器 (CFSR - Configurable Fault Status Register)</h4><p>CFSR 寄存器可分为三个状态寄存器：用法故障 (Usage Fault)、总线故障 (Bus Fault) 和 内存管理故障 (MemManage Fault) 状态寄存器。<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/CFSR.png"></p>
<h5 id="6-2-1-内存管理状态寄存器-MMFSR-MemManage-Status-Register"><a href="#6-2-1-内存管理状态寄存器-MMFSR-MemManage-Status-Register" class="headerlink" title="6.2.1 内存管理状态寄存器 (MMFSR - MemManage Status Register)"></a>6.2.1 内存管理状态寄存器 (MMFSR - MemManage Status Register)</h5><p>内存管理故障状态寄存器 (MMFSR) 指示由 内存保护单元 (MPU - Memory Protection Unit) 检测到的内存访问违规。该寄存器仅允许特权访问。非特权访问将生成总线故障 (BusFault)。</p>
<p>MMFSR 包含以下状态位：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/MMFSR.png"><br>IACCVIOL (指令访问违规标志)：</p>
<ul>
<li>0 &#x3D; 无指令访问违规故障</li>
<li>1 &#x3D; 处理器尝试从不允许执行的位置获取指令。</li>
<li>为异常返回而压入堆栈的 PC 值指向引发故障的指令。处理器未将故障地址写入 MMFAR。</li>
</ul>
<p>此故障条件发生在任何尝试从 XN (eXecute Never, 永不执行) 区域获取指令的时候，即使 MPU 被禁用或不存在也会发生。<br>潜在原因：<br>a) 跳转（Branch）到 MPU 中未定义或定义为不可执行的区域。<br>b) 由于栈内容损坏而导致无效返回。<br>c) 异常向量表中的条目不正确。</p>
<p>DACCVIOL (数据访问违规标志)：</p>
<ul>
<li>0 &#x3D; 无数据访问违规故障</li>
<li>1 &#x3D; 处理器尝试在不允许该操作（加载或存储）的位置进行数据访问。</li>
<li>为异常返回而压入堆栈的 PC 值指向引发故障的指令。处理器已将尝试访问的数据地址加载到了 MMFAR 中。</li>
</ul>
<p>MUNSTKERR (异常返回出栈过程中发生的内存管理故障)：</p>
<ul>
<li>0 &#x3D; 无出栈故障</li>
<li>1 &#x3D; 为异常返回而进行的出栈操作导致了一次或多次访问违规。</li>
<li>此故障与处理程序是链式（chained） 的，这意味着原始的返回栈仍然存在。处理器未从失败返回中调整 SP（栈指针），也未执行新的上下文保存。处理器未将故障地址写入 MMFAR。<br>潜在原因：<br>a) 栈指针 (SP) 已损坏。<br>b) 异常处理程序执行期间，用于栈的 MPU 区域发生了更改。</li>
</ul>
<p>MSTKERR (异常入口压栈过程中发生的内存管理故障)：</p>
<ul>
<li>0 &#x3D; 无压栈故障</li>
<li>1 &#x3D; 为异常入口而进行的压栈操作导致了一次或多次访问违规。</li>
<li>SP 已被调整，但栈上上下文区域中的值可能是错误的。处理器未将故障地址写入 MMFAR。<br>潜在原因：<br>a) 栈指针 (SP) 已损坏或未初始化。<br>b) 栈触及到了 MPU 未定义为读&#x2F;写内存的区域。</li>
</ul>
<p>MLSPERR (浮点惰性状态保存期间的内存管理故障) (仅限带 FPU 的 Cortex-M4)：</p>
<ul>
<li>0 &#x3D; 浮点惰性状态保存期间未发生故障</li>
<li>1 &#x3D; 浮点惰性状态保存期间发生故障</li>
<li>PS：惰性保存：发生异常时，处理器暂时不保存浮点寄存器，它只是标记一个“FPU状态需要保存”的标志。只有当异常处理程序内部第一次尝试执行浮点指令时，处理器才会检测到这个标志，并在此时真正执行保存所有浮点寄存器的操作。<br>浮点惰性状态保存期间的内存管理故障:在惰性保存机制被触发的那个时间点（即异常处理程序中第一次执行浮点指令，处理器需要将S0-S31等FPU寄存器保存到堆栈时），此次保存操作本身（一次对堆栈的大规模写操作）违反了MPU的规则，从而触发了内存管理故障（MemManage Fault）。</li>
</ul>
<p>MMARVALID (内存管理故障地址寄存器 (MMFAR) 有效标志)：</p>
<ul>
<li>0 &#x3D; SCB-&gt;MMFAR 中的值不是有效的故障地址</li>
<li>1 &#x3D; SCB-&gt;MMFAR 中持有有效的故障地址。</li>
</ul>
<p>如果发生内存管理故障，并因优先级原因升级 (escalated) 为 HardFault，则 HardFault 处理程序必须将此位清零 (0)。这样可以避免在返回到一个栈上的活动 MemManage 故障处理程序时出现问题，因为该处理程序的 SCB-&gt;MMFAR 值可能已被覆盖。</p>
<h5 id="6-2-2-总线故障状态寄存器-BFSR-BusFault-Status-Register"><a href="#6-2-2-总线故障状态寄存器-BFSR-BusFault-Status-Register" class="headerlink" title="6.2.2 总线故障状态寄存器 (BFSR - BusFault Status Register)"></a>6.2.2 总线故障状态寄存器 (BFSR - BusFault Status Register)</h5><p>总线故障状态寄存器显示了由指令预取和数据访问引起的总线错误状态，并指示在总线操作期间检测到的存储器访问故障。该寄存器仅允许特权访问。非特权访问将生成总线故障。</p>
<p>BFSR 包含以下状态位：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/BFSR.png"></p>
<p>IBUSERR (指令总线错误)：</p>
<ul>
<li>0 &#x3D; 无指令总线错误</li>
<li>1 &#x3D; 发生指令总线错误。</li>
<li>处理器在预取指令时检测到指令总线错误，但仅当它尝试执行该故障指令时才会将 IBUSERR 标志置 1。当处理器置位此位时，不会将故障地址写入 BFAR。<br>潜在原因：<br>a) 跳转到无效内存区域，例如由不正确的函数指针引起。<br>b) 由于栈指针或栈内容损坏而导致无效返回。<br>c) 异常向量表中的条目不正确。</li>
</ul>
<p>PRECISERR (精确数据总线错误)：</p>
<ul>
<li>0 &#x3D; 无精确数据总线错误</li>
<li>1 &#x3D; 已发生数据总线错误，且为异常返回而压入堆栈的 PC 值精确指向了引发故障的指令。<br>当处理器置位此位时，它会将故障地址写入 BFAR。这对于调试至关重要。</li>
</ul>
<p>IMPRECISERR (不精确数据总线错误)：</p>
<ul>
<li>0 &#x3D; 无不精确数据总线错误</li>
<li>1 &#x3D; 已发生数据总线错误，但栈帧中的返回地址与引发错误的指令无关。</li>
<li>当处理器置位此位时，它不会将故障地址写入 BFAR。这是一种异步故障。因此，如果在当前进程的优先级高于总线故障优先级时检测到它，则总线故障会保持挂起 (pending) 状态，仅当处理器从所有更高优先级进程返回后才会变为活动 (active) 状态。如果在处理器进入不精确总线故障的处理程序之前发生了精确故障，则处理程序会检测到 IMPRECISERR 置 1 并且某个精确故障状态位也置 1。</li>
</ul>
<p>UNSTKERR (异常返回出栈过程中的总线故障)：</p>
<ul>
<li>0 &#x3D; 无出栈故障</li>
<li>1 &#x3D; 为异常返回而进行的出栈操作导致了一次或多次总线故障。</li>
<li>此故障与处理程序是链式（chained） 的。这意味着当处理器置位此位时，原始的返回栈仍然存在。处理器不会从失败返回中调整 SP（栈指针），不会执行新的上下文保存，也不会将故障地址写入 BFAR。</li>
</ul>
<p>STKERR (异常入口压栈过程中的总线故障)：</p>
<ul>
<li>0 &#x3D; 无压栈故障</li>
<li>1 &#x3D; 为异常入口而进行的压栈操作导致了一次或多次总线故障。<br>当处理器置位此位时，SP 已被调整，但栈上上下文区域中的值可能是错误的。处理器不会将故障地址写入 BFAR。<br>潜在原因：<br>a) 栈指针 (SP) 已损坏或未初始化。<br>b) 栈触及到了未定义的存储器区域。</li>
</ul>
<p>LSPERR (浮点惰性状态保存期间的总线故障) (仅在存在 FPU 时)：</p>
<ul>
<li>0 &#x3D; 浮点惰性状态保存期间未发生故障</li>
<li>1 &#x3D; 浮点惰性状态保存期间发生故障<br>(其机制与 MemManage 故障中的 MLSPERR 类似，但触发的是总线错误而非内存保护错误)。</li>
</ul>
<p>BFARVALID (总线故障地址寄存器 (BFAR) 有效标志)：</p>
<ul>
<li>0 &#x3D; BFAR 中的值不是有效的故障地址</li>
<li>1 &#x3D; BFAR 中持有有效的故障地址。</li>
</ul>
<p>处理器在地址已知的总线故障发生后置位此位。其他故障（例如随后发生的 MemManage 故障）可以将此位清零。如果发生总线故障并因优先级原因升级为 HardFault，则 HardFault 处理程序必须将此位清零 (0)。这样可以避免在返回到一个栈上的活动 BusFault 故障处理程序时出现问题，因为该处理程序的 BFAR 值可能已被覆盖。</p>
<h5 id="6-2-3-用法故障状态寄存器-UFSR-UsageFault-Status-Register"><a href="#6-2-3-用法故障状态寄存器-UFSR-UsageFault-Status-Register" class="headerlink" title="6.2.3 用法故障状态寄存器 (UFSR - UsageFault Status Register)"></a>6.2.3 用法故障状态寄存器 (UFSR - UsageFault Status Register)</h5><p>用法故障状态寄存器 (UFSR) 包含了某些指令执行故障和数据访问故障的状态。该寄存器仅允许特权访问。非特权访问将生成总线故障 (BusFault)。</p>
<p>该寄存器包含以下定义位：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/UFSR.png"></p>
<p>UNDEFINSTR (未定义指令)：</p>
<ul>
<li>0 &#x3D; 无未定义指令</li>
<li>1 &#x3D; 处理器尝试执行一条未定义指令。</li>
<li>当此位置 1 时，为异常返回而压入堆栈的 PC 值指向该未定义指令。未定义指令指处理器无法解码的指令。<br>潜在原因：<br>a) 使用了 Cortex-M 设备不支持的指令（例如 ARM 模式下的指令）。<br>b) 内存内容错误或损坏（例如，数据被错误地当作指令执行）。</li>
</ul>
<p>INVSTATE (无效状态)：</p>
<ul>
<li>0 &#x3D; 无无效状态</li>
<li>1 &#x3D; 处理器尝试执行一条对 执行程序状态寄存器 (EPSR - Execution Program Status Register) 进行了非法使用的指令。</li>
<li>当此位置 1 时，为异常返回而压入堆栈的 PC 值指向那条试图非法使用 EPSR 的指令。<br>潜在原因：<br>a) 向 PC 寄存器加载了一个最低有效位 (LSB) 为 0 的分支目标地址（Cortex-M 的指令必须是半字对齐的，PC 的 LSB 应为 1）。<br>b) 在异常或中断处理期间，压入堆栈的 PSR 值被损坏。<br>c) 向量表中包含了一个 LSB 为 0 的向量地址。</li>
</ul>
<p>INVPC (无效的 PC 加载)：</p>
<ul>
<li>0 &#x3D; 无无效的 PC 加载</li>
<li>1 &#x3D; 由于无效的 EXC_RETURN 值，处理器尝试将一个非法的 EXC_RETURN 值加载到 PC 寄存器，这通常源于一次无效的上下文切换。</li>
<li>当此位置 1 时，为异常返回而压入堆栈的 PC 值指向那条试图执行非法 PC 加载的指令。<br>潜在原因：<br>a) 由于栈指针、链接寄存器 (LR) 或栈内容损坏而导致无效返回。<br>b) PSR 中的 ICI&#x2F;IT 位对于当前指令无效（Thumb 状态下的条件执行或中断继续指令状态不一致）。</li>
</ul>
<p>NOCP (无协处理器)：</p>
<ul>
<li>0 &#x3D; 无因尝试访问协处理器而引起的用法故障</li>
<li>1 &#x3D; 处理器尝试访问一个不存在的协处理器。</li>
<li>Cortex-M 系列通常不支持协处理器，此位用于捕获试图执行协处理器指令的行为。</li>
</ul>
<p>UNALIGNED (未对齐访问)：</p>
<ul>
<li><p>0 &#x3D; 无未对齐访问故障，或未使能未对齐访问陷阱</p>
</li>
<li><p>1 &#x3D; 处理器进行了一次未对齐的内存访问（例如，尝试从非 4 字节对齐的地址读取一个 32 位字）。</p>
</li>
<li><p>通过设置 CCR (配置与控制寄存器) 中的 UNALIGN_TRP 位来使能未对齐访问陷阱。请注意：<strong>LDM, STM, LDRD, 和 STRD 指令的未对齐访问总是会引发故障，而与 UNALIGN_TRP 位的设置无关</strong>。</p>
</li>
</ul>
<p>DIVBYZERO (除零错误)：</p>
<ul>
<li>0 &#x3D; 无除零错误，或未使能除零陷阱</li>
<li>1 &#x3D; 处理器执行了一条 SDIV 或 UDIV（有符号或无符号除法）指令，且除数为 0。</li>
<li>当处理器将此位置 1 时，为异常返回而压入堆栈的 PC 值指向那条执行了除零操作的指令。通过将 CCR 寄存器中的 DIV_0_TRP 位设置为 1 来使能除零陷阱。</li>
</ul>
<p>请注意：用法故障状态寄存器中的位是粘滞 (sticky) 的。这意味着，一旦一个或多个故障发生，相关的位就会被置 1。一个被置 1 的位只能通过向该位写入 1 或通过系统复位来清零。</p>
<h4 id="6-3-内存管理故障地址寄存器-MMFAR-MemManage-Fault-Address-Register"><a href="#6-3-内存管理故障地址寄存器-MMFAR-MemManage-Fault-Address-Register" class="headerlink" title="6.3 内存管理故障地址寄存器 (MMFAR - MemManage Fault Address Register)"></a>6.3 内存管理故障地址寄存器 (MMFAR - MemManage Fault Address Register)</h4><p>MMFAR 寄存器包含了引发内存管理故障的访问操作所指向的内存地址。</p>
<p>ADDRESS (故障地址)：该字段保存了引发内存管理故障的数据访问地址。</p>
<p>此寄存器会更新为产生内存管理故障的访问地址。而 MMFSR 寄存器则指明了故障的具体原因。</p>
<p><strong>该字段仅在 MMFSR.MMARVALID 位被置 1 时才有效。</strong></p>
<p>在那些 没有独立实现 BFAR (总线故障地址寄存器) 和 MMFAR 的处理器实现中，如果 BFSR.BFARVALID 位被置 1（表明总线故障地址有效），此寄存器的值将是未知的 (UNKNOWN)。</p>
<h4 id="6-4总线故障地址寄存器-BFAR-BusFault-Address-Register"><a href="#6-4总线故障地址寄存器-BFAR-BusFault-Address-Register" class="headerlink" title="6.4总线故障地址寄存器 (BFAR - BusFault Address Register)"></a>6.4总线故障地址寄存器 (BFAR - BusFault Address Register)</h4><p>BFAR 中的地址与精确数据访问总线故障相关联。该寄存器仅允许特权访问。非特权访问将生成总线故障。</p>
<p>ADDRESS (故障地址)：该字段保存了引发精确总线故障的数据访问地址。</p>
<p>此寄存器会更新为产生总线故障的访问地址。而 BFSR 寄存器则指明了故障的具体原因。<strong>该字段仅在 BFSR.BFARVALID 位被置 1 时才有效。</strong></p>
<p>在那些没有独立实现 BFAR (总线故障地址寄存器) 和 MMFAR (内存管理故障地址寄存器) 的处理器实现中，如果 MMFSR.MMARVALID 位被置 1（表明内存管理故障地址有效），此寄存器的值将是未知的 (UNKNOWN)。</p>
<h4 id="6-5-辅助总线故障状态寄存器-ABFSR-Auxiliary-Bus-Fault-Status-Register-仅-Cortex-M7"><a href="#6-5-辅助总线故障状态寄存器-ABFSR-Auxiliary-Bus-Fault-Status-Register-仅-Cortex-M7" class="headerlink" title="6.5 辅助总线故障状态寄存器 (ABFSR - Auxiliary Bus Fault Status Register) (仅 Cortex-M7)"></a>6.5 辅助总线故障状态寄存器 (ABFSR - Auxiliary Bus Fault Status Register) (仅 Cortex-M7)</h4><p>辅助总线故障状态寄存器 (ABFSR) 存储了关于异步总线故障源的信息。如果发生了总线故障，故障处理程序可以读取此寄存器以确定是哪个总线接口触发了故障；如果故障源是 AXIM 接口，还能确定接收到的错误类型。ABFSR[4:0] 字段的值会一直保持有效，直到通过向 ABFSR 写入任意值来将其清除。ABFSR 的位定义如下：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/ABFSR.png"></p>
<p>AXIMTYPE (AXIM 接口故障类型)：指示在 AXIM 接口上发生的故障类型。仅当 AXIM 位为 1 时，这些值才有效。</p>
<ul>
<li>0b00 &#x3D; OKAY (正常响应)</li>
<li>0b01 &#x3D; EXOKAY (独占访问正常响应)</li>
<li>0b10 &#x3D; SLVERR (从设备错误)</li>
<li>0b11 &#x3D; DECERR (解码错误)</li>
</ul>
<p>EPPB (EPPB 接口异步故障)：指示 EPPB 接口上发生了异步故障。</p>
<p>AXIM (AXIM 接口异步故障)：指示 AXIM 接口上发生了异步故障。</p>
<p>AHBP (AHBP 接口异步故障)：指示 AHBP 接口上发生了异步故障。</p>
<p>DTCM (DTCM 接口异步故障)：指示 DTCM (数据紧耦合存储器) 接口上发生了异步故障。</p>
<p>ITCM (ITCM 接口异步故障)：指示 ITCM (指令紧耦合存储器) 接口上发生了异步故障。</p>
<p>注意： 上述接口在具体芯片上可能并未实现。</p>
<h3 id="7-实现故障处理程序"><a href="#7-实现故障处理程序" class="headerlink" title="7 实现故障处理程序"></a>7 实现故障处理程序</h3><p>故障处理程序可用于安全地关闭系统、向用户通报所遇到的问题，或者触发整个系统的自检。</p>
<p>一个符合 CMSIS 标准的启动文件（通常命名为 startup_device.s）定义了设备的所有异常和中断向量。这些向量定义了异常或中断处理函数的入口地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">__Vectors DCD __initial_sp ; Top of Stack</span><br><span class="line">          DCD Reset_Handler ; Reset Handler</span><br><span class="line">          DCD NMI_Handler ; NMI Handler</span><br><span class="line">          DCD HardFault_Handler ; Hard Fault Handler</span><br><span class="line">          DCD MemManage_Handler ; MPU Fault Handler</span><br><span class="line">          DCD BusFault_Handler ; Bus Fault Handler</span><br><span class="line">          DCD UsageFault_Handler ; Usage Fault Handler</span><br><span class="line">          DCD <span class="number">0</span> ; Reserved</span><br><span class="line">          :</span><br></pre></td></tr></table></figure>


<h4 id="7-1-HardFault-处理程序示例"><a href="#7-1-HardFault-处理程序示例" class="headerlink" title="7.1 HardFault 处理程序示例"></a>7.1 HardFault 处理程序示例</h4><p>AN209_Faults_and_Handler.zip 压缩包包含了一个示例项目，其中有一个示范性的 HardFault 处理程序。该处理程序会保存内核寄存器的内容，并使用 printf 语句将其显示出来。这个自定义处理程序由两部分组成：</p>
<ul>
<li>用汇编语言编写的处理程序包装器：它负责提取栈帧的位置，并将其作为一个指针传递给用 C 语言编写的处理程序。</li>
<li>用 C 语言编写的处理程序：它利用来自汇编包装器的信息来提取相关信息，并使用 printf 语句将其显示，如下图所示：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/handler_output.png"></li>
</ul>
<p>对于一个最终应用程序，可以实现一个执行以下操作的故障处理程序：</p>
<ul>
<li>系统复位 (System Reset)：通过设置 AIRCR (应用程序中断和复位控制寄存器) 中的位 2 (SYSRESETREQ)。这将复位系统中除调试逻辑之外的大部分部件。如果不想复位整个系统，只需设置 AIRCR 中的位 0 (VECTRESET)，这将仅导致处理器内核复位。</li>
<li>恢复 (Recovery)：在某些情况下，或许可以解决导致故障异常的问题。例如，对于协处理器指令，处理程序可以在软件中模拟执行该指令。</li>
<li>任务终止 (Task termination)：对于运行实时操作系统 (RTOS) 的系统，可以终止引发故障的任务，并在需要时重新启动它。</li>
</ul>
<h4 id="7-2-ARM-Cortex-M7-故障处理注意事项"><a href="#7-2-ARM-Cortex-M7-故障处理注意事项" class="headerlink" title="7.2 ARM Cortex-M7 故障处理注意事项"></a>7.2 ARM Cortex-M7 故障处理注意事项</h4><p>1: 缓存维护操作可能导致总线故障 (BusFault)。此类故障事件是异步的（不精确的）。这种类型的总线故障：</p>
<ul>
<li>a. 在已启用总线故障处理程序的情况下，不会升级 (escalate) 为 HardFault。</li>
<li>b. 永远不会导致系统锁定 (lockup)。</li>
</ul>
<p>由于故障事件是异步的，执行缓存维护操作的软件代码在操作完成时必须使用内存屏障指令（如 DSB），以便能够立即观察到该故障事件。</p>
<p>2: Cortex-M7 中的缓存支持 ECC（错误校正码）。一旦发生不可纠正的 ECC 错误，将触发总线故障 (BusFault)，软件可以通过指令错误存储库寄存器 (IEBR0-1) 和数据错误存储库寄存器 (DEBR0-1) 来管理 ECC 错误。</p>
<p>3: 由于总线接口的设计不同，（Cortex-M7）在总线错误行为上存在一些差异：</p>
<ul>
<li>a. 在 Cortex-M3 和 Cortex-M4 上，如果内存操作是向强有序 (strongly ordered) 内存区域进行写入，其产生的总线错误是精确的。而在 Cortex-M7 上，相同的操作可能触发不精确的总线错误。</li>
<li>b. 在 Cortex-M3 和 Cortex-M4 上，异常序列在未完成的缓冲写入操作完成之后才开始。因此，如果发生总线错误，堆栈中保存的 PC 值与触发总线错误的代码上下文相同。在 Cortex-M7 上，异常处理序列可以在写缓冲区 (write buffer) 被清空之前就开始。在这种情况下，堆栈中保存的 PC 值可能显示不同的上下文（例如，可能在缓冲写入操作发生后不久触发了一个 IRQ 中断处理程序）。因此，在 Cortex-M7 上，如果总线故障是异步的，其处理程序不能依赖堆栈中的 PC 值来确定故障位置。</li>
<li>PS: Cortex-M7 更深的Store Buffer,当Store Buffer中的写入操作失败时，错误报告会延迟，此时CPU的上下文（如PC值）可能已经改变。</li>
</ul>
<h3 id="8-使用-µVision®-调试故障"><a href="#8-使用-µVision®-调试故障" class="headerlink" title="8 使用 µVision® 调试故障"></a>8 使用 µVision® 调试故障</h3><p>该示例项目 (<a target="_blank" rel="noopener" href="http://www.keil.com/appnotes/docs/apnt_209.asp">www.keil.com/appnotes/docs/apnt_209.asp</a>) 演示了三种不同的故障异常：</p>
<ul>
<li>调用一条不属于 ARM 指令集的指令，将导致 未定义指令用法故障 (UNDEFINSTR)。</li>
<li>跳转到一个有效但未设置 Thumb 位的内存地址，将导致 无效状态用法故障 (INVSTATE)。</li>
<li>任何数字除以零的操作，将触发 除零用法故障 (DIVBYZERO)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i, j = <span class="number">0</span>;                  <span class="comment">// Variables for the division-by-zero</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function written in assembly language, calling an invalid instruction</span></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">undef</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DCI  <span class="number">0xF123</span>                         <span class="comment">// DCI is not an ARM assmebly instruction</span></span><br><span class="line">    DCI  <span class="number">0x4567</span></span><br><span class="line">    BX   LR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function containing all the tests</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  SCB-&gt;CCR = <span class="number">0x210</span>;                     <span class="comment">// enable div-by-zero trap in processor core</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TESTCASE == 0</span></span><br><span class="line">	undef();                              <span class="comment">// Call undef() function that contains an</span></span><br><span class="line">	                                      <span class="comment">// invalid instruction</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> TESTCASE == 1</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*t_funcPtr)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">  t_funcPtr MyFunc = (t_funcPtr)(<span class="number">0x0001000</span> | <span class="number">0x0</span>);  <span class="comment">// INVSTATE because jumping</span></span><br><span class="line">	                                                  <span class="comment">// to valid address but</span></span><br><span class="line">	                                                  <span class="comment">// thumb bit not set</span></span><br><span class="line">	MyFunc();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> TESTCASE == 2</span></span><br><span class="line">  i =i/j;                               <span class="comment">// i and j are 0 initialized -&gt; Div/0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-从“外设”菜单访问故障报告对话框"><a href="#8-1-从“外设”菜单访问故障报告对话框" class="headerlink" title="8.1 从“外设”菜单访问故障报告对话框"></a>8.1 从“外设”菜单访问故障报告对话框</h4><p>ARM Cortex-M 故障寄存器会准确指示发生了哪种异常。µVision 在 “外设 (Peripherals)” –&gt; “内核外设 (Core Peripherals)” 菜单下的 “故障报告 (Fault Reports)” 对话框中提供了所有故障寄存器的当前值。<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Fault_Reports_dialog.png"></p>
<p>该故障报告对话框提供了已发生异常的详细信息。在此案例中（软件包示例项目中的 TESTCASE INVSTATE），是一次尝试切换到无效状态（ARM 状态） 的操作导致了用法故障 (UsageFault)；并且由于用法故障处理程序未启用，该故障被升级 (escalated) 为了硬故障 (HardFault)。<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Faults_Reports_dialog.png"></p>
<p>此故障报告对话框是分析故障异常的快捷途径。如果您的调试器不支持此类对话框，则可以通过内存窗口 (memory window) 来查看这些寄存器的值。</p>
<h4 id="8-2-确定异常发生的位置"><a href="#8-2-确定异常发生的位置" class="headerlink" title="8.2 确定异常发生的位置"></a>8.2 确定异常发生的位置</h4><p>异常发生时，硬件自动压栈，异常栈帧结构如下：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Exception_stack_frame.png"></p>
<p>在示例项目中，使能 DIVBYZERO (除零) 用法故障，然后运行应用程序直至其最终进入 HardFault。</p>
<p>在 “调用堆栈 + 局部变量 (Call Stack + Locals)”窗口中，右键单击 HardFault_Handler，然后选择 “查看调用者代码 (Show Caller Code)”，以高亮显示异常发生时的执行上下文：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/display_call_stack.png"></p>
<p>根据异常类型的不同，调试器会高亮显示导致异常的指令，或者导致故障的指令的下一条指令。这取决于导致异常的指令是否实际上已经执行完成。<br>在 main.c 中，以下行被高亮显示：<br>i &#x3D;i&#x2F;j; &#x2F;&#x2F; i and j are 0 initialized -&gt; Div&#x2F;0</p>
<p>发生异常时，会保存寄存器 R0-R3, R12, PC 和 LR 的状态，以及 MSP 或 PSP 的值（具体取决于异常发生时正在使用的堆栈）。当前的链接寄存器 LR 包含正在处理的异常的 EXC_RETURN 值，该值指示了哪个堆栈保存着来自应用程序上下文的寄存器值。如果 EXC_RETURN 的位 2 为 0，则表示使用的是主堆栈（MSP 被保存），否则使用的是进程堆栈（PSP 被保存）。寄存器 (Registers) 窗口提供了所需的信息：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Registers_Window.png"></p>
<p>在此示例中，EXC_RETURN 的值为：<br>0xfffffff9 &#x3D; b_11111111111111111111111111111001 – 位 2 &#x3D; 0<br>这表示主堆栈 (MSP) 包含了最近存储的寄存器值。MSP 和 PSP 的地址在此处也可见。</p>
<p>MSP 指向 0x20001050。可以使用内存窗口 (Memory Window) 来查看先前的执行上下文：<br><img src="/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/Execution_context_stored_on_the_stack.png"></p>
<p>这对应于我们之前在调试器中看到的信息：</p>
<ul>
<li>PC &#x3D; 0x00000249： 即将导致用法故障的下一条指令（此处为：SDIV 指令之后）。</li>
<li>R0-R3 &amp; R12： 这些是异常发生前寄存器中的值。</li>
</ul>
<p>通过利用来自故障状态寄存器的详细信息以及相应的堆栈，调试器提供了发现发生了何种异常以及异常发生位置所需的信息。要进一步调试此特定问题（除零），必须复位系统，并在被破坏的函数指针上设置观察点 (watch point)。这将揭示问题的根本原因。</p>
<h3 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h3><p>【1】<a target="_blank" rel="noopener" href="https://documentation-service.arm.com/static/61084e4a3d73a34b640e31eb">APNT209.pdf</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>feng xun
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://fengxun2017.github.io/2025/09/14/Arm%20cortex-m%20Fault%20Exceptions/" title="ARM Cortex-m Fault Exceptions 文档学习">http://fengxun2017.github.io/2025/09/14/Arm cortex-m Fault Exceptions/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/06/10/tricore-architecture-Trap%20System/" rel="prev" title="tricore architecture - Trap System">
                  <i class="fa fa-chevron-left"></i> tricore architecture - Trap System
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/24/TCPIP-lwip-ipinput/" rel="next" title="lwip ip层处理逻辑梳理">
                  lwip ip层处理逻辑梳理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">feng xun</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">552k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:30</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
